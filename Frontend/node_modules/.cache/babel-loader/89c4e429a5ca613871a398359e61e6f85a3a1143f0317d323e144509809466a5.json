{"ast":null,"code":"/**\n * Classes and utilities for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\n\nimport { ValueTypes, expressionToGlsl, getStringNumberEquivalent, uniformNameForVariable } from '../style/expressions.js';\n\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSizeExpression('...')\n *   .outputSymbolFragmentShader();\n * ```\n */\nexport class ShaderBuilder {\n  constructor() {\n    /**\n     * Uniforms; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.uniforms = [];\n\n    /**\n     * Attributes; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.attributes = [];\n\n    /**\n     * Varyings with a name, a type and an expression.\n     * @type {Array<VaryingDescription>}\n     * @private\n     */\n    this.varyings = [];\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.sizeExpression = 'vec2(1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.rotationExpression = '0.0';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.offsetExpression = 'vec2(0.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.colorExpression = 'vec4(1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.texCoordExpression = 'vec4(0.0, 0.0, 1.0, 1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.discardExpression = 'false';\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.rotateWithView = false;\n  }\n\n  /**\n   * Adds a uniform accessible in both fragment and vertex shaders.\n   * The given name should include a type, such as `sampler2D u_texture`.\n   * @param {string} name Uniform name\n   * @return {ShaderBuilder} the builder object\n   */\n  addUniform(name) {\n    this.uniforms.push(name);\n    return this;\n  }\n\n  /**\n   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n   * The given name should include a type, such as `vec2 a_position`.\n   * @param {string} name Attribute name\n   * @return {ShaderBuilder} the builder object\n   */\n  addAttribute(name) {\n    this.attributes.push(name);\n    return this;\n  }\n\n  /**\n   * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n   * The type and expression of the varying have to be specified separately.\n   * @param {string} name Varying name\n   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n   * @param {string} expression Expression used to assign a value to the varying.\n   * @return {ShaderBuilder} the builder object\n   */\n  addVarying(name, type, expression) {\n    this.varyings.push({\n      name: name,\n      type: type,\n      expression: expression\n    });\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the size of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSizeExpression(expression) {\n    this.sizeExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the rotation of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `float` value in radians.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setRotationExpression(expression) {\n    this.rotationExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the offset of the symbol from the point center.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * Note: will only be used for point geometry shaders.\n   * @param {string} expression Offset expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolOffsetExpression(expression) {\n    this.offsetExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the color of the shape.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Color expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setColorExpression(expression) {\n    this.colorExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the texture coordinates of the vertices.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Texture coordinate expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setTextureCoordinateExpression(expression) {\n    this.texCoordExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to determine whether a fragment (pixel) should be discarded,\n   * i.e. not drawn at all.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `bool` value (it will be\n   * used in an `if` statement)\n   * @param {string} expression Fragment discard expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setFragmentDiscardExpression(expression) {\n    this.discardExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets whether the symbols should rotate with the view or stay aligned with the map.\n   * Note: will only be used for point geometry shaders.\n   * @param {boolean} rotateWithView Rotate with view\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolRotateWithView(rotateWithView) {\n    this.rotateWithView = rotateWithView;\n    return this;\n  }\n\n  /**\n   * @return {string} Previously set size expression\n   */\n  getSizeExpression() {\n    return this.sizeExpression;\n  }\n\n  /**\n   * @return {string} Previously set symbol offset expression\n   */\n  getOffsetExpression() {\n    return this.offsetExpression;\n  }\n\n  /**\n   * @return {string} Previously set color expression\n   */\n  getColorExpression() {\n    return this.colorExpression;\n  }\n\n  /**\n   * @return {string} Previously set texture coordinate expression\n   */\n  getTextureCoordinateExpression() {\n    return this.texCoordExpression;\n  }\n\n  /**\n   * @return {string} Previously set fragment discard expression\n   */\n  getFragmentDiscardExpression() {\n    return this.discardExpression;\n  }\n\n  /**\n   * Generates a symbol vertex shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Three uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,\n   * `u_offsetRotateMatrix`, `u_time`.\n   *\n   * The following attributes are hardcoded and expected to be present in the vertex buffers:\n   * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3).\n   *\n   * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @return {string} The full shader as a string.\n   */\n  getSymbolVertexShader(forHitDetection) {\n    const offsetMatrix = this.rotateWithView ? 'u_offsetScaleMatrix * u_offsetRotateMatrix' : 'u_offsetScaleMatrix';\n    let attributes = this.attributes;\n    let varyings = this.varyings;\n    if (forHitDetection) {\n      attributes = attributes.concat('vec4 a_hitColor');\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor'\n      });\n    }\n    return `precision mediump float;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n${this.uniforms.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n')}\nattribute vec2 a_position;\nattribute float a_index;\n${attributes.map(function (attribute) {\n      return 'attribute ' + attribute + ';';\n    }).join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n${varyings.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n')}\nvoid main(void) {\n  mat4 offsetMatrix = ${offsetMatrix};\n  vec2 halfSize = ${this.sizeExpression} * 0.5;\n  vec2 offset = ${this.offsetExpression};\n  float angle = ${this.rotationExpression};\n  float offsetX;\n  float offsetY;\n  if (a_index == 0.0) {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  } else if (a_index == 1.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else if (a_index == 2.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  }\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  vec4 texCoord = ${this.texCoordExpression};\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v_quadCoord = vec2(u, v);\n${varyings.map(function (varying) {\n      return '  ' + varying.name + ' = ' + varying.expression + ';';\n    }).join('\\n')}\n}`;\n  }\n\n  /**\n   * Generates a symbol fragment shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Expects the following varyings to be transmitted by the vertex shader:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @return {string} The full shader as a string.\n   */\n  getSymbolFragmentShader(forHitDetection) {\n    const hitDetectionBypass = forHitDetection ? '  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;' : '';\n    let varyings = this.varyings;\n    if (forHitDetection) {\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor'\n      });\n    }\n    return `precision mediump float;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n${this.uniforms.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n${varyings.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n')}\nvoid main(void) {\n  if (${this.discardExpression}) { discard; }\n  gl_FragColor = ${this.colorExpression};\n  gl_FragColor.rgb *= gl_FragColor.a;\n${hitDetectionBypass}\n}`;\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {Object<string,import(\"./Helper\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../renderer/webgl/PointsLayer\").CustomAttribute>} attributes Attribute descriptions.\n */\n\n/**\n * Parses a {@link import(\"../style/literal\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/literal\").LiteralStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  const symbStyle = style.symbol;\n  const size = symbStyle.size !== undefined ? symbStyle.size : 1;\n  const color = symbStyle.color || 'white';\n  const texCoord = symbStyle.textureCoord || [0, 0, 1, 1];\n  const offset = symbStyle.offset || [0, 0];\n  const opacity = symbStyle.opacity !== undefined ? symbStyle.opacity : 1;\n  const rotation = symbStyle.rotation !== undefined ? symbStyle.rotation : 0;\n\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {},\n    functions: {}\n  };\n  const parsedSize = expressionToGlsl(vertContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER);\n  const parsedOffset = expressionToGlsl(vertContext, offset, ValueTypes.NUMBER_ARRAY);\n  const parsedTexCoord = expressionToGlsl(vertContext, texCoord, ValueTypes.NUMBER_ARRAY);\n  const parsedRotation = expressionToGlsl(vertContext, rotation, ValueTypes.NUMBER);\n\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    stringLiteralsMap: vertContext.stringLiteralsMap,\n    functions: {}\n  };\n  const parsedColor = expressionToGlsl(fragContext, color, ValueTypes.COLOR);\n  const parsedOpacity = expressionToGlsl(fragContext, opacity, ValueTypes.NUMBER);\n  let opacityFilter = '1.0';\n  const visibleSize = `vec2(${expressionToGlsl(fragContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER)}).x`;\n  switch (symbStyle.symbolType) {\n    case 'square':\n      break;\n    case 'image':\n      break;\n    // taken from https://thebookofshaders.com/07/\n    case 'circle':\n      opacityFilter = `(1.0-smoothstep(1.-4./${visibleSize},1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))`;\n      break;\n    case 'triangle':\n      const st = '(v_quadCoord*2.-1.)';\n      const a = `(atan(${st}.x,${st}.y))`;\n      opacityFilter = `(1.0-smoothstep(.5-3./${visibleSize},.5,cos(floor(.5+${a}/2.094395102)*2.094395102-${a})*length(${st})))`;\n      break;\n    default:\n      throw new Error('Unexpected symbol type: ' + symbStyle.symbolType);\n  }\n  const builder = new ShaderBuilder().setSizeExpression(`vec2(${parsedSize})`).setRotationExpression(parsedRotation).setSymbolOffsetExpression(parsedOffset).setTextureCoordinateExpression(parsedTexCoord).setSymbolRotateWithView(!!symbStyle.rotateWithView).setColorExpression(`vec4(${parsedColor}.rgb, ${parsedColor}.a * ${parsedOpacity} * ${opacityFilter})`);\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(fragContext, style.filter, ValueTypes.BOOLEAN);\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  // define one uniform per variable\n  fragContext.variables.forEach(function (varName) {\n    const uniformName = uniformNameForVariable(varName);\n    builder.addUniform(`float ${uniformName}`);\n    uniforms[uniformName] = function () {\n      if (!style.variables || style.variables[varName] === undefined) {\n        throw new Error(`The following variable is missing from the style: ${varName}`);\n      }\n      let value = style.variables[varName];\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(vertContext, value);\n      }\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  });\n\n  if (symbStyle.symbolType === 'image' && symbStyle.src) {\n    const texture = new Image();\n    texture.crossOrigin = symbStyle.crossOrigin === undefined ? 'anonymous' : symbStyle.crossOrigin;\n    texture.src = symbStyle.src;\n    builder.addUniform('sampler2D u_texture').setColorExpression(builder.getColorExpression() + ' * texture2D(u_texture, v_texCoord)');\n    uniforms['u_texture'] = texture;\n  }\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  fragContext.attributes.forEach(function (attrName) {\n    if (!vertContext.attributes.includes(attrName)) {\n      vertContext.attributes.push(attrName);\n    }\n    builder.addVarying(`v_${attrName}`, 'float', `a_${attrName}`);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  vertContext.attributes.forEach(function (attrName) {\n    builder.addAttribute(`float a_${attrName}`);\n  });\n  return {\n    builder: builder,\n    attributes: vertContext.attributes.map(function (attributeName) {\n      return {\n        name: attributeName,\n        callback: function (feature, props) {\n          let value = props[attributeName];\n          if (typeof value === 'string') {\n            value = getStringNumberEquivalent(vertContext, value);\n          }\n          return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n        }\n      };\n    }),\n\n    uniforms: uniforms\n  };\n}","map":{"version":3,"names":["ValueTypes","expressionToGlsl","getStringNumberEquivalent","uniformNameForVariable","ShaderBuilder","constructor","uniforms","attributes","varyings","sizeExpression","rotationExpression","offsetExpression","colorExpression","texCoordExpression","discardExpression","rotateWithView","addUniform","name","push","addAttribute","addVarying","type","expression","setSizeExpression","setRotationExpression","setSymbolOffsetExpression","setColorExpression","setTextureCoordinateExpression","setFragmentDiscardExpression","setSymbolRotateWithView","getSizeExpression","getOffsetExpression","getColorExpression","getTextureCoordinateExpression","getFragmentDiscardExpression","getSymbolVertexShader","forHitDetection","offsetMatrix","concat","map","uniform","join","attribute","varying","getSymbolFragmentShader","hitDetectionBypass","parseLiteralStyle","style","symbStyle","symbol","size","undefined","color","texCoord","textureCoord","offset","opacity","rotation","vertContext","inFragmentShader","variables","stringLiteralsMap","functions","parsedSize","NUMBER_ARRAY","NUMBER","parsedOffset","parsedTexCoord","parsedRotation","fragContext","parsedColor","COLOR","parsedOpacity","opacityFilter","visibleSize","symbolType","st","a","Error","builder","filter","parsedFilter","BOOLEAN","forEach","varName","uniformName","value","src","texture","Image","crossOrigin","attrName","includes","attributeName","callback","feature","props"],"sources":["/Users/lydiaprice/quake-text/Frontend/node_modules/ol/webgl/ShaderBuilder.js"],"sourcesContent":["/**\n * Classes and utilities for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\n\nimport {\n  ValueTypes,\n  expressionToGlsl,\n  getStringNumberEquivalent,\n  uniformNameForVariable,\n} from '../style/expressions.js';\n\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSizeExpression('...')\n *   .outputSymbolFragmentShader();\n * ```\n */\nexport class ShaderBuilder {\n  constructor() {\n    /**\n     * Uniforms; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.uniforms = [];\n\n    /**\n     * Attributes; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.attributes = [];\n\n    /**\n     * Varyings with a name, a type and an expression.\n     * @type {Array<VaryingDescription>}\n     * @private\n     */\n    this.varyings = [];\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.sizeExpression = 'vec2(1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.rotationExpression = '0.0';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.offsetExpression = 'vec2(0.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.colorExpression = 'vec4(1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.texCoordExpression = 'vec4(0.0, 0.0, 1.0, 1.0)';\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.discardExpression = 'false';\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.rotateWithView = false;\n  }\n\n  /**\n   * Adds a uniform accessible in both fragment and vertex shaders.\n   * The given name should include a type, such as `sampler2D u_texture`.\n   * @param {string} name Uniform name\n   * @return {ShaderBuilder} the builder object\n   */\n  addUniform(name) {\n    this.uniforms.push(name);\n    return this;\n  }\n\n  /**\n   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n   * The given name should include a type, such as `vec2 a_position`.\n   * @param {string} name Attribute name\n   * @return {ShaderBuilder} the builder object\n   */\n  addAttribute(name) {\n    this.attributes.push(name);\n    return this;\n  }\n\n  /**\n   * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n   * The type and expression of the varying have to be specified separately.\n   * @param {string} name Varying name\n   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n   * @param {string} expression Expression used to assign a value to the varying.\n   * @return {ShaderBuilder} the builder object\n   */\n  addVarying(name, type, expression) {\n    this.varyings.push({\n      name: name,\n      type: type,\n      expression: expression,\n    });\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the size of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSizeExpression(expression) {\n    this.sizeExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the rotation of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `float` value in radians.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setRotationExpression(expression) {\n    this.rotationExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the offset of the symbol from the point center.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * Note: will only be used for point geometry shaders.\n   * @param {string} expression Offset expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolOffsetExpression(expression) {\n    this.offsetExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the color of the shape.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Color expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setColorExpression(expression) {\n    this.colorExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to compute the texture coordinates of the vertices.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Texture coordinate expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setTextureCoordinateExpression(expression) {\n    this.texCoordExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets an expression to determine whether a fragment (pixel) should be discarded,\n   * i.e. not drawn at all.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `bool` value (it will be\n   * used in an `if` statement)\n   * @param {string} expression Fragment discard expression\n   * @return {ShaderBuilder} the builder object\n   */\n  setFragmentDiscardExpression(expression) {\n    this.discardExpression = expression;\n    return this;\n  }\n\n  /**\n   * Sets whether the symbols should rotate with the view or stay aligned with the map.\n   * Note: will only be used for point geometry shaders.\n   * @param {boolean} rotateWithView Rotate with view\n   * @return {ShaderBuilder} the builder object\n   */\n  setSymbolRotateWithView(rotateWithView) {\n    this.rotateWithView = rotateWithView;\n    return this;\n  }\n\n  /**\n   * @return {string} Previously set size expression\n   */\n  getSizeExpression() {\n    return this.sizeExpression;\n  }\n\n  /**\n   * @return {string} Previously set symbol offset expression\n   */\n  getOffsetExpression() {\n    return this.offsetExpression;\n  }\n\n  /**\n   * @return {string} Previously set color expression\n   */\n  getColorExpression() {\n    return this.colorExpression;\n  }\n\n  /**\n   * @return {string} Previously set texture coordinate expression\n   */\n  getTextureCoordinateExpression() {\n    return this.texCoordExpression;\n  }\n\n  /**\n   * @return {string} Previously set fragment discard expression\n   */\n  getFragmentDiscardExpression() {\n    return this.discardExpression;\n  }\n\n  /**\n   * Generates a symbol vertex shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Three uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,\n   * `u_offsetRotateMatrix`, `u_time`.\n   *\n   * The following attributes are hardcoded and expected to be present in the vertex buffers:\n   * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3).\n   *\n   * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @return {string} The full shader as a string.\n   */\n  getSymbolVertexShader(forHitDetection) {\n    const offsetMatrix = this.rotateWithView\n      ? 'u_offsetScaleMatrix * u_offsetRotateMatrix'\n      : 'u_offsetScaleMatrix';\n\n    let attributes = this.attributes;\n    let varyings = this.varyings;\n\n    if (forHitDetection) {\n      attributes = attributes.concat('vec4 a_hitColor');\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor',\n      });\n    }\n\n    return `precision mediump float;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n${this.uniforms\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nattribute vec2 a_position;\nattribute float a_index;\n${attributes\n  .map(function (attribute) {\n    return 'attribute ' + attribute + ';';\n  })\n  .join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n${varyings\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\nvoid main(void) {\n  mat4 offsetMatrix = ${offsetMatrix};\n  vec2 halfSize = ${this.sizeExpression} * 0.5;\n  vec2 offset = ${this.offsetExpression};\n  float angle = ${this.rotationExpression};\n  float offsetX;\n  float offsetY;\n  if (a_index == 0.0) {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  } else if (a_index == 1.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else if (a_index == 2.0) {\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\n  } else {\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\n  }\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  vec4 texCoord = ${this.texCoordExpression};\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\n  v_quadCoord = vec2(u, v);\n${varyings\n  .map(function (varying) {\n    return '  ' + varying.name + ' = ' + varying.expression + ';';\n  })\n  .join('\\n')}\n}`;\n  }\n\n  /**\n   * Generates a symbol fragment shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Expects the following varyings to be transmitted by the vertex shader:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @return {string} The full shader as a string.\n   */\n  getSymbolFragmentShader(forHitDetection) {\n    const hitDetectionBypass = forHitDetection\n      ? '  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;'\n      : '';\n\n    let varyings = this.varyings;\n\n    if (forHitDetection) {\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor',\n      });\n    }\n\n    return `precision mediump float;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\n${this.uniforms\n  .map(function (uniform) {\n    return 'uniform ' + uniform + ';';\n  })\n  .join('\\n')}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\n${varyings\n  .map(function (varying) {\n    return 'varying ' + varying.type + ' ' + varying.name + ';';\n  })\n  .join('\\n')}\nvoid main(void) {\n  if (${this.discardExpression}) { discard; }\n  gl_FragColor = ${this.colorExpression};\n  gl_FragColor.rgb *= gl_FragColor.a;\n${hitDetectionBypass}\n}`;\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {Object<string,import(\"./Helper\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../renderer/webgl/PointsLayer\").CustomAttribute>} attributes Attribute descriptions.\n */\n\n/**\n * Parses a {@link import(\"../style/literal\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/literal\").LiteralStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  const symbStyle = style.symbol;\n  const size = symbStyle.size !== undefined ? symbStyle.size : 1;\n  const color = symbStyle.color || 'white';\n  const texCoord = symbStyle.textureCoord || [0, 0, 1, 1];\n  const offset = symbStyle.offset || [0, 0];\n  const opacity = symbStyle.opacity !== undefined ? symbStyle.opacity : 1;\n  const rotation = symbStyle.rotation !== undefined ? symbStyle.rotation : 0;\n\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {},\n    functions: {},\n  };\n  const parsedSize = expressionToGlsl(\n    vertContext,\n    size,\n    ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER\n  );\n  const parsedOffset = expressionToGlsl(\n    vertContext,\n    offset,\n    ValueTypes.NUMBER_ARRAY\n  );\n  const parsedTexCoord = expressionToGlsl(\n    vertContext,\n    texCoord,\n    ValueTypes.NUMBER_ARRAY\n  );\n  const parsedRotation = expressionToGlsl(\n    vertContext,\n    rotation,\n    ValueTypes.NUMBER\n  );\n\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    stringLiteralsMap: vertContext.stringLiteralsMap,\n    functions: {},\n  };\n  const parsedColor = expressionToGlsl(fragContext, color, ValueTypes.COLOR);\n  const parsedOpacity = expressionToGlsl(\n    fragContext,\n    opacity,\n    ValueTypes.NUMBER\n  );\n\n  let opacityFilter = '1.0';\n  const visibleSize = `vec2(${expressionToGlsl(\n    fragContext,\n    size,\n    ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER\n  )}).x`;\n  switch (symbStyle.symbolType) {\n    case 'square':\n      break;\n    case 'image':\n      break;\n    // taken from https://thebookofshaders.com/07/\n    case 'circle':\n      opacityFilter = `(1.0-smoothstep(1.-4./${visibleSize},1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))`;\n      break;\n    case 'triangle':\n      const st = '(v_quadCoord*2.-1.)';\n      const a = `(atan(${st}.x,${st}.y))`;\n      opacityFilter = `(1.0-smoothstep(.5-3./${visibleSize},.5,cos(floor(.5+${a}/2.094395102)*2.094395102-${a})*length(${st})))`;\n      break;\n\n    default:\n      throw new Error('Unexpected symbol type: ' + symbStyle.symbolType);\n  }\n\n  const builder = new ShaderBuilder()\n    .setSizeExpression(`vec2(${parsedSize})`)\n    .setRotationExpression(parsedRotation)\n    .setSymbolOffsetExpression(parsedOffset)\n    .setTextureCoordinateExpression(parsedTexCoord)\n    .setSymbolRotateWithView(!!symbStyle.rotateWithView)\n    .setColorExpression(\n      `vec4(${parsedColor}.rgb, ${parsedColor}.a * ${parsedOpacity} * ${opacityFilter})`\n    );\n\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(\n      fragContext,\n      style.filter,\n      ValueTypes.BOOLEAN\n    );\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  // define one uniform per variable\n  fragContext.variables.forEach(function (varName) {\n    const uniformName = uniformNameForVariable(varName);\n    builder.addUniform(`float ${uniformName}`);\n    uniforms[uniformName] = function () {\n      if (!style.variables || style.variables[varName] === undefined) {\n        throw new Error(\n          `The following variable is missing from the style: ${varName}`\n        );\n      }\n      let value = style.variables[varName];\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(vertContext, value);\n      }\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  });\n\n  if (symbStyle.symbolType === 'image' && symbStyle.src) {\n    const texture = new Image();\n    texture.crossOrigin =\n      symbStyle.crossOrigin === undefined ? 'anonymous' : symbStyle.crossOrigin;\n    texture.src = symbStyle.src;\n    builder\n      .addUniform('sampler2D u_texture')\n      .setColorExpression(\n        builder.getColorExpression() + ' * texture2D(u_texture, v_texCoord)'\n      );\n    uniforms['u_texture'] = texture;\n  }\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  fragContext.attributes.forEach(function (attrName) {\n    if (!vertContext.attributes.includes(attrName)) {\n      vertContext.attributes.push(attrName);\n    }\n    builder.addVarying(`v_${attrName}`, 'float', `a_${attrName}`);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  vertContext.attributes.forEach(function (attrName) {\n    builder.addAttribute(`float a_${attrName}`);\n  });\n\n  return {\n    builder: builder,\n    attributes: vertContext.attributes.map(function (attributeName) {\n      return {\n        name: attributeName,\n        callback: function (feature, props) {\n          let value = props[attributeName];\n          if (typeof value === 'string') {\n            value = getStringNumberEquivalent(vertContext, value);\n          }\n          return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n        },\n      };\n    }),\n    uniforms: uniforms,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}