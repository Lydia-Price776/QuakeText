{"ast":null,"code":"/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\n\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport { Uniforms } from '../renderer/webgl/TileLayer.js';\nimport { asArray, fromString, isStringColor } from '../color.js';\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expressions.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName']` fetches a feature attribute (it will be prefixed by `a_` in the shader)\n *     Note: those will be taken from the attributes provided to the renderer\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables, or 0 if undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2]` multiplies `value1` by `value2`\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2]` adds `value1` and `value2`\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\nexport const ValueTypes = {\n  NUMBER: 0b00001,\n  STRING: 0b00010,\n  COLOR: 0b00100,\n  BOOLEAN: 0b01000,\n  NUMBER_ARRAY: 0b10000,\n  ANY: 0b11111,\n  NONE: 0\n};\n\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes=): string} toGlsl Returns a GLSL-compatible string\n * Note: takes in an optional type hint as 3rd parameter\n */\n\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\nexport const Operators = {};\n\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @return {ValueTypes|number} Type or types inferred from the value\n */\nexport function getValueType(value) {\n  if (typeof value === 'number') {\n    return ValueTypes.NUMBER;\n  }\n  if (typeof value === 'boolean') {\n    return ValueTypes.BOOLEAN;\n  }\n  if (typeof value === 'string') {\n    if (isStringColor(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n    return ValueTypes.STRING;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(`Unhandled value type: ${JSON.stringify(value)}`);\n  }\n  const valueArr = /** @type {Array<*>} */value;\n  const onlyNumbers = valueArr.every(function (v) {\n    return typeof v === 'number';\n  });\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n    return ValueTypes.NUMBER_ARRAY;\n  }\n  if (typeof valueArr[0] !== 'string') {\n    throw new Error(`Expected an expression operator but received: ${JSON.stringify(valueArr)}`);\n  }\n  const operator = Operators[valueArr[0]];\n  if (operator === undefined) {\n    throw new Error(`Unrecognized expression operator: ${JSON.stringify(valueArr)}`);\n  }\n  return operator.getReturnType(valueArr.slice(1));\n}\n\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\nexport function isTypeUnique(valueType) {\n  return Math.log2(valueType) % 1 === 0;\n}\n\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<string>} variables List of variables used in the expression; contains **unprefixed names**\n * @property {Array<string>} attributes List of attributes used in the expression; contains **unprefixed names**\n * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n */\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color).slice();\n  if (array.length < 4) {\n    array.push(1);\n  }\n  return arrayToGlsl(array.map(function (c, i) {\n    return i < 3 ? c / 255 : c;\n  }));\n}\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(context, string) {\n  if (context.stringLiteralsMap[string] === undefined) {\n    context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;\n  }\n  return context.stringLiteralsMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(context, string) {\n  return numberToGlsl(getStringNumberEquivalent(context, string));\n}\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [typeHint] Hint for the expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(context, value, typeHint) {\n  // operator\n  if (Array.isArray(value) && typeof value[0] === 'string') {\n    const operator = Operators[value[0]];\n    if (operator === undefined) {\n      throw new Error(`Unrecognized expression operator: ${JSON.stringify(value)}`);\n    }\n    return operator.toGlsl(context, value.slice(1), typeHint);\n  }\n  const valueType = getValueType(value);\n  if ((valueType & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl( /** @type {number} */value);\n  }\n  if ((valueType & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  }\n  if ((valueType & ValueTypes.STRING) > 0 && (typeHint === undefined || typeHint == ValueTypes.STRING)) {\n    return stringToGlsl(context, value.toString());\n  }\n  if ((valueType & ValueTypes.COLOR) > 0 && (typeHint === undefined || typeHint == ValueTypes.COLOR)) {\n    return colorToGlsl( /** @type {Array<number> | string} */value);\n  }\n  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl( /** @type {Array<number>} */value);\n  }\n  throw new Error(`Unexpected expression ${value} (expected type ${typeHint})`);\n}\nfunction assertNumber(value) {\n  if (!(getValueType(value) & ValueTypes.NUMBER)) {\n    throw new Error(`A numeric value was expected, got ${JSON.stringify(value)} instead`);\n  }\n}\nfunction assertNumbers(values) {\n  for (let i = 0; i < values.length; i++) {\n    assertNumber(values[i]);\n  }\n}\nfunction assertString(value) {\n  if (!(getValueType(value) & ValueTypes.STRING)) {\n    throw new Error(`A string value was expected, got ${JSON.stringify(value)} instead`);\n  }\n}\nfunction assertBoolean(value) {\n  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {\n    throw new Error(`A boolean value was expected, got ${JSON.stringify(value)} instead`);\n  }\n}\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(`Exactly ${count} arguments were expected, got ${args.length} instead`);\n  }\n}\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(`At least ${count} arguments were expected, got ${args.length} instead`);\n  }\n}\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(`At most ${count} arguments were expected, got ${args.length} instead`);\n  }\n}\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(`An even amount of arguments was expected, got ${args} instead`);\n  }\n}\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(`An odd amount of arguments was expected, got ${args} instead`);\n  }\n}\nfunction assertUniqueInferredType(args, types) {\n  if (!isTypeUnique(types)) {\n    throw new Error(`Could not infer only one type from the following expression: ${JSON.stringify(args)}`);\n  }\n}\nOperators['get'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const value = args[0].toString();\n    if (!context.attributes.includes(value)) {\n      context.attributes.push(value);\n    }\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + value;\n  }\n};\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\nOperators['var'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const value = args[0].toString();\n    if (!context.variables.includes(value)) {\n      context.variables.push(value);\n    }\n    return uniformNameForVariable(value);\n  }\n};\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n// ['palette', index, colors]\nOperators['palette'] = {\n  getReturnType: function (args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumber(args[0]);\n    const index = expressionToGlsl(context, args[0]);\n    const colors = args[1];\n    if (!Array.isArray(colors)) {\n      throw new Error('The second argument of palette must be an array');\n    }\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < numColors; i++) {\n      const candidate = colors[i];\n      /**\n       * @type {import('../color.js').Color}\n       */\n      let color;\n      if (typeof candidate === 'string') {\n        color = fromString(candidate);\n      } else {\n        if (!Array.isArray(candidate)) {\n          throw new Error('The second argument of palette must be an array of strings or colors');\n        }\n        const length = candidate.length;\n        if (length === 4) {\n          color = candidate;\n        } else {\n          if (length !== 3) {\n            throw new Error(`Expected palette color to have 3 or 4 values, got ${length}`);\n          }\n          color = [candidate[0], candidate[1], candidate[2], 1];\n        }\n      }\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    return `texture2D(${paletteName}, vec2((${index} + 0.5) / ${numColors}.0, 0.5))`;\n  }\n};\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\nOperators['band'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 3);\n    const band = args[0];\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `\n          if (band == ${i + 1}.0) {\n            return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n          }\n        `;\n      }\n      context.functions[GET_BAND_VALUE_FUNC] = `\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n          float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n          ${ifBlocks}\n        }\n      `;\n    }\n    const bandExpression = expressionToGlsl(context, band);\n    const xOffsetExpression = expressionToGlsl(context, args[1] || 0);\n    const yOffsetExpression = expressionToGlsl(context, args[2] || 0);\n    return `${GET_BAND_VALUE_FUNC}(${bandExpression}, ${xOffsetExpression}, ${yOffsetExpression})`;\n  }\n};\nOperators['time'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_time';\n  }\n};\nOperators['zoom'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_zoom';\n  }\n};\nOperators['resolution'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_resolution';\n  }\n};\nOperators['*'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} * ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['/'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} / ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['+'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} + ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['-'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} - ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['clamp'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    return `clamp(${expressionToGlsl(context, args[0])}, ${min}, ${max})`;\n  }\n};\nOperators['%'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `mod(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['^'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `pow(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['abs'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `abs(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['floor'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['round'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])} + 0.5)`;\n  }\n};\nOperators['ceil'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `ceil(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['sin'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `sin(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['cos'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `cos(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['atan'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertNumbers(args);\n    return args.length === 2 ? `atan(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(context, args[1])})` : `atan(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['>'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} > ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['>='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} >= ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['<'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} < ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['<='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} <= ${expressionToGlsl(context, args[1])})`;\n  }\n};\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsCount(args, 2);\n\n      // find common type\n      let type = ValueTypes.ANY;\n      for (let i = 0; i < args.length; i++) {\n        type &= getValueType(args[i]);\n      }\n      if (type === ValueTypes.NONE) {\n        throw new Error(`All arguments should be of compatible type, got ${JSON.stringify(args)} instead`);\n      }\n\n      // Since it's not possible to have color types here, we can leave it out\n      // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')\n      type &= ~ValueTypes.COLOR;\n      return `(${expressionToGlsl(context, args[0], type)} ${operator} ${expressionToGlsl(context, args[1], type)})`;\n    }\n  };\n}\nOperators['=='] = getEqualOperator('==');\nOperators['!='] = getEqualOperator('!=');\nOperators['!'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return `(!${expressionToGlsl(context, args[0])})`;\n  }\n};\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsMinCount(args, 2);\n      for (let i = 0; i < args.length; i++) {\n        assertBoolean(args[i]);\n      }\n      let result = '';\n      result = args.map(arg => expressionToGlsl(context, arg)).join(` ${operator} `);\n      result = `(${result})`;\n      return result;\n    }\n  };\n}\nOperators['all'] = getDecisionOperator('&&');\nOperators['any'] = getDecisionOperator('||');\nOperators['between'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    const value = expressionToGlsl(context, args[0]);\n    return `(${value} >= ${min} && ${value} <= ${max})`;\n  }\n};\nOperators['array'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args.map(function (val) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER);\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  }\n};\nOperators['color'] = {\n  getReturnType: function (args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const array = /** @type {Array<number>} */args;\n    if (args.length === 3) {\n      array.push(1);\n    }\n    const parsedArgs = args.map(function (val, i) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER) + (i < 3 ? ' / 255.0' : '');\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  }\n};\nOperators['interpolate'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.COLOR | ValueTypes.NUMBER;\n    for (let i = 3; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    return type;\n  },\n  toGlsl: function (context, args, typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6);\n\n    // validate interpolation type\n    const type = args[0];\n    let interpolation;\n    switch (type[0]) {\n      case 'linear':\n        interpolation = 1;\n        break;\n      case 'exponential':\n        interpolation = type[1];\n        break;\n      default:\n        interpolation = null;\n    }\n    if (!interpolation) {\n      throw new Error(`Invalid interpolation type for \"interpolate\" operator, received: ${JSON.stringify(type)}`);\n    }\n\n    // compute input/output types\n    typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;\n    const outputType = Operators['interpolate'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    const input = expressionToGlsl(context, args[1]);\n    const exponent = numberToGlsl(interpolation);\n    let result = '';\n    for (let i = 2; i < args.length - 2; i += 2) {\n      const stop1 = expressionToGlsl(context, args[i]);\n      const output1 = result || expressionToGlsl(context, args[i + 1], outputType);\n      const stop2 = expressionToGlsl(context, args[i + 2]);\n      const output2 = expressionToGlsl(context, args[i + 3], outputType);\n      result = `mix(${output1}, ${output2}, pow(clamp((${input} - ${stop1}) / (${stop2} - ${stop1}), 0.0, 1.0), ${exponent}))`;\n    }\n    return result;\n  }\n};\nOperators['match'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 2; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n    typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;\n    const outputType = Operators['match'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    const input = expressionToGlsl(context, args[0]);\n    const fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    let result = null;\n    for (let i = args.length - 3; i >= 1; i -= 2) {\n      const match = expressionToGlsl(context, args[i]);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }\n};\nOperators['case'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 1; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, typeHint) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n    typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;\n    const outputType = Operators['case'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    for (let i = 0; i < args.length - 1; i += 2) {\n      assertBoolean(args[i]);\n    }\n    const fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    let result = null;\n    for (let i = args.length - 3; i >= 0; i -= 2) {\n      const condition = expressionToGlsl(context, args[i]);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }\n};","map":{"version":3,"names":["PaletteTexture","Uniforms","asArray","fromString","isStringColor","ValueTypes","NUMBER","STRING","COLOR","BOOLEAN","NUMBER_ARRAY","ANY","NONE","Operators","getValueType","value","Array","isArray","Error","JSON","stringify","valueArr","onlyNumbers","every","v","length","operator","undefined","getReturnType","slice","isTypeUnique","valueType","Math","log2","numberToGlsl","s","toString","includes","arrayToGlsl","array","map","join","colorToGlsl","color","push","c","i","getStringNumberEquivalent","context","string","stringLiteralsMap","Object","keys","stringToGlsl","expressionToGlsl","typeHint","toGlsl","assertNumber","assertNumbers","values","assertString","assertBoolean","assertArgsCount","args","count","assertArgsMinCount","assertArgsMaxCount","assertArgsEven","assertArgsOdd","assertUniqueInferredType","types","attributes","prefix","inFragmentShader","uniformNameForVariable","variableName","variables","PALETTE_TEXTURE_ARRAY","index","colors","numColors","palette","Uint8Array","candidate","offset","paletteTextures","paletteName","paletteTexture","GET_BAND_VALUE_FUNC","band","functions","ifBlocks","bandCount","colorIndex","floor","bandIndex","textureName","TILE_TEXTURE_ARRAY","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","bandExpression","xOffsetExpression","yOffsetExpression","min","max","getEqualOperator","type","getDecisionOperator","result","arg","parsedArgs","val","interpolation","outputType","input","exponent","stop1","output1","stop2","output2","fallback","match","output","condition"],"sources":["/Users/lydiaprice/quake-text/Frontend/node_modules/ol/style/expressions.js"],"sourcesContent":["/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\n\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport {Uniforms} from '../renderer/webgl/TileLayer.js';\nimport {asArray, fromString, isStringColor} from '../color.js';\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expressions.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName']` fetches a feature attribute (it will be prefixed by `a_` in the shader)\n *     Note: those will be taken from the attributes provided to the renderer\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables, or 0 if undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2]` multiplies `value1` by `value2`\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2]` adds `value1` and `value2`\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\nexport const ValueTypes = {\n  NUMBER: 0b00001,\n  STRING: 0b00010,\n  COLOR: 0b00100,\n  BOOLEAN: 0b01000,\n  NUMBER_ARRAY: 0b10000,\n  ANY: 0b11111,\n  NONE: 0,\n};\n\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes=): string} toGlsl Returns a GLSL-compatible string\n * Note: takes in an optional type hint as 3rd parameter\n */\n\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\nexport const Operators = {};\n\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @return {ValueTypes|number} Type or types inferred from the value\n */\nexport function getValueType(value) {\n  if (typeof value === 'number') {\n    return ValueTypes.NUMBER;\n  }\n  if (typeof value === 'boolean') {\n    return ValueTypes.BOOLEAN;\n  }\n  if (typeof value === 'string') {\n    if (isStringColor(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n    return ValueTypes.STRING;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(`Unhandled value type: ${JSON.stringify(value)}`);\n  }\n  const valueArr = /** @type {Array<*>} */ (value);\n  const onlyNumbers = valueArr.every(function (v) {\n    return typeof v === 'number';\n  });\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n    return ValueTypes.NUMBER_ARRAY;\n  }\n  if (typeof valueArr[0] !== 'string') {\n    throw new Error(\n      `Expected an expression operator but received: ${JSON.stringify(\n        valueArr\n      )}`\n    );\n  }\n  const operator = Operators[valueArr[0]];\n  if (operator === undefined) {\n    throw new Error(\n      `Unrecognized expression operator: ${JSON.stringify(valueArr)}`\n    );\n  }\n  return operator.getReturnType(valueArr.slice(1));\n}\n\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\nexport function isTypeUnique(valueType) {\n  return Math.log2(valueType) % 1 === 0;\n}\n\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<string>} variables List of variables used in the expression; contains **unprefixed names**\n * @property {Array<string>} attributes List of attributes used in the expression; contains **unprefixed names**\n * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n */\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error(\n      '`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.'\n    );\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color).slice();\n  if (array.length < 4) {\n    array.push(1);\n  }\n  return arrayToGlsl(\n    array.map(function (c, i) {\n      return i < 3 ? c / 255 : c;\n    })\n  );\n}\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(context, string) {\n  if (context.stringLiteralsMap[string] === undefined) {\n    context.stringLiteralsMap[string] = Object.keys(\n      context.stringLiteralsMap\n    ).length;\n  }\n  return context.stringLiteralsMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(context, string) {\n  return numberToGlsl(getStringNumberEquivalent(context, string));\n}\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [typeHint] Hint for the expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(context, value, typeHint) {\n  // operator\n  if (Array.isArray(value) && typeof value[0] === 'string') {\n    const operator = Operators[value[0]];\n    if (operator === undefined) {\n      throw new Error(\n        `Unrecognized expression operator: ${JSON.stringify(value)}`\n      );\n    }\n    return operator.toGlsl(context, value.slice(1), typeHint);\n  }\n\n  const valueType = getValueType(value);\n  if ((valueType & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl(/** @type {number} */ (value));\n  }\n\n  if ((valueType & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  }\n\n  if (\n    (valueType & ValueTypes.STRING) > 0 &&\n    (typeHint === undefined || typeHint == ValueTypes.STRING)\n  ) {\n    return stringToGlsl(context, value.toString());\n  }\n\n  if (\n    (valueType & ValueTypes.COLOR) > 0 &&\n    (typeHint === undefined || typeHint == ValueTypes.COLOR)\n  ) {\n    return colorToGlsl(/** @type {Array<number> | string} */ (value));\n  }\n\n  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl(/** @type {Array<number>} */ (value));\n  }\n\n  throw new Error(`Unexpected expression ${value} (expected type ${typeHint})`);\n}\n\nfunction assertNumber(value) {\n  if (!(getValueType(value) & ValueTypes.NUMBER)) {\n    throw new Error(\n      `A numeric value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertNumbers(values) {\n  for (let i = 0; i < values.length; i++) {\n    assertNumber(values[i]);\n  }\n}\nfunction assertString(value) {\n  if (!(getValueType(value) & ValueTypes.STRING)) {\n    throw new Error(\n      `A string value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertBoolean(value) {\n  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {\n    throw new Error(\n      `A boolean value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(\n      `Exactly ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(\n      `At least ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(\n      `At most ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(\n      `An even amount of arguments was expected, got ${args} instead`\n    );\n  }\n}\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(\n      `An odd amount of arguments was expected, got ${args} instead`\n    );\n  }\n}\nfunction assertUniqueInferredType(args, types) {\n  if (!isTypeUnique(types)) {\n    throw new Error(\n      `Could not infer only one type from the following expression: ${JSON.stringify(\n        args\n      )}`\n    );\n  }\n}\n\nOperators['get'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const value = args[0].toString();\n    if (!context.attributes.includes(value)) {\n      context.attributes.push(value);\n    }\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + value;\n  },\n};\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\nOperators['var'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const value = args[0].toString();\n    if (!context.variables.includes(value)) {\n      context.variables.push(value);\n    }\n    return uniformNameForVariable(value);\n  },\n};\n\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n// ['palette', index, colors]\nOperators['palette'] = {\n  getReturnType: function (args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumber(args[0]);\n    const index = expressionToGlsl(context, args[0]);\n    const colors = args[1];\n    if (!Array.isArray(colors)) {\n      throw new Error('The second argument of palette must be an array');\n    }\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < numColors; i++) {\n      const candidate = colors[i];\n      /**\n       * @type {import('../color.js').Color}\n       */\n      let color;\n      if (typeof candidate === 'string') {\n        color = fromString(candidate);\n      } else {\n        if (!Array.isArray(candidate)) {\n          throw new Error(\n            'The second argument of palette must be an array of strings or colors'\n          );\n        }\n        const length = candidate.length;\n        if (length === 4) {\n          color = candidate;\n        } else {\n          if (length !== 3) {\n            throw new Error(\n              `Expected palette color to have 3 or 4 values, got ${length}`\n            );\n          }\n          color = [candidate[0], candidate[1], candidate[2], 1];\n        }\n      }\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    return `texture2D(${paletteName}, vec2((${index} + 0.5) / ${numColors}.0, 0.5))`;\n  },\n};\n\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\n\nOperators['band'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 3);\n    const band = args[0];\n\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `\n          if (band == ${i + 1}.0) {\n            return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n          }\n        `;\n      }\n\n      context.functions[GET_BAND_VALUE_FUNC] = `\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n          float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n          ${ifBlocks}\n        }\n      `;\n    }\n\n    const bandExpression = expressionToGlsl(context, band);\n    const xOffsetExpression = expressionToGlsl(context, args[1] || 0);\n    const yOffsetExpression = expressionToGlsl(context, args[2] || 0);\n    return `${GET_BAND_VALUE_FUNC}(${bandExpression}, ${xOffsetExpression}, ${yOffsetExpression})`;\n  },\n};\n\nOperators['time'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_time';\n  },\n};\n\nOperators['zoom'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_zoom';\n  },\n};\n\nOperators['resolution'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_resolution';\n  },\n};\n\nOperators['*'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} * ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['/'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} / ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['+'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} + ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['-'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} - ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['clamp'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    return `clamp(${expressionToGlsl(context, args[0])}, ${min}, ${max})`;\n  },\n};\n\nOperators['%'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `mod(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['^'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `pow(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['abs'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `abs(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['floor'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['round'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])} + 0.5)`;\n  },\n};\n\nOperators['ceil'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `ceil(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['sin'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `sin(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['cos'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `cos(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['atan'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertNumbers(args);\n    return args.length === 2\n      ? `atan(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n          context,\n          args[1]\n        )})`\n      : `atan(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['>'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} > ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['>='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} >= ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['<'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} < ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['<='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} <= ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsCount(args, 2);\n\n      // find common type\n      let type = ValueTypes.ANY;\n      for (let i = 0; i < args.length; i++) {\n        type &= getValueType(args[i]);\n      }\n      if (type === ValueTypes.NONE) {\n        throw new Error(\n          `All arguments should be of compatible type, got ${JSON.stringify(\n            args\n          )} instead`\n        );\n      }\n\n      // Since it's not possible to have color types here, we can leave it out\n      // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')\n      type &= ~ValueTypes.COLOR;\n\n      return `(${expressionToGlsl(\n        context,\n        args[0],\n        type\n      )} ${operator} ${expressionToGlsl(context, args[1], type)})`;\n    },\n  };\n}\n\nOperators['=='] = getEqualOperator('==');\n\nOperators['!='] = getEqualOperator('!=');\n\nOperators['!'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return `(!${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsMinCount(args, 2);\n      for (let i = 0; i < args.length; i++) {\n        assertBoolean(args[i]);\n      }\n      let result = '';\n      result = args\n        .map((arg) => expressionToGlsl(context, arg))\n        .join(` ${operator} `);\n      result = `(${result})`;\n      return result;\n    },\n  };\n}\n\nOperators['all'] = getDecisionOperator('&&');\n\nOperators['any'] = getDecisionOperator('||');\n\nOperators['between'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    const value = expressionToGlsl(context, args[0]);\n    return `(${value} >= ${min} && ${value} <= ${max})`;\n  },\n};\n\nOperators['array'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args.map(function (val) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER);\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  },\n};\n\nOperators['color'] = {\n  getReturnType: function (args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const array = /** @type {Array<number>} */ (args);\n    if (args.length === 3) {\n      array.push(1);\n    }\n    const parsedArgs = args.map(function (val, i) {\n      return (\n        expressionToGlsl(context, val, ValueTypes.NUMBER) +\n        (i < 3 ? ' / 255.0' : '')\n      );\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  },\n};\n\nOperators['interpolate'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.COLOR | ValueTypes.NUMBER;\n    for (let i = 3; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    return type;\n  },\n  toGlsl: function (context, args, typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6);\n\n    // validate interpolation type\n    const type = args[0];\n    let interpolation;\n    switch (type[0]) {\n      case 'linear':\n        interpolation = 1;\n        break;\n      case 'exponential':\n        interpolation = type[1];\n        break;\n      default:\n        interpolation = null;\n    }\n    if (!interpolation) {\n      throw new Error(\n        `Invalid interpolation type for \"interpolate\" operator, received: ${JSON.stringify(\n          type\n        )}`\n      );\n    }\n\n    // compute input/output types\n    typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;\n    const outputType = Operators['interpolate'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n\n    const input = expressionToGlsl(context, args[1]);\n    const exponent = numberToGlsl(interpolation);\n\n    let result = '';\n    for (let i = 2; i < args.length - 2; i += 2) {\n      const stop1 = expressionToGlsl(context, args[i]);\n      const output1 =\n        result || expressionToGlsl(context, args[i + 1], outputType);\n      const stop2 = expressionToGlsl(context, args[i + 2]);\n      const output2 = expressionToGlsl(context, args[i + 3], outputType);\n      result = `mix(${output1}, ${output2}, pow(clamp((${input} - ${stop1}) / (${stop2} - ${stop1}), 0.0, 1.0), ${exponent}))`;\n    }\n    return result;\n  },\n};\n\nOperators['match'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 2; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n\n    typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;\n    const outputType = Operators['match'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n\n    const input = expressionToGlsl(context, args[0]);\n    const fallback = expressionToGlsl(\n      context,\n      args[args.length - 1],\n      outputType\n    );\n    let result = null;\n    for (let i = args.length - 3; i >= 1; i -= 2) {\n      const match = expressionToGlsl(context, args[i]);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  },\n};\n\nOperators['case'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 1; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, typeHint) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n\n    typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;\n    const outputType = Operators['case'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    for (let i = 0; i < args.length - 1; i += 2) {\n      assertBoolean(args[i]);\n    }\n\n    const fallback = expressionToGlsl(\n      context,\n      args[args.length - 1],\n      outputType\n    );\n    let result = null;\n    for (let i = args.length - 3; i >= 0; i -= 2) {\n      const condition = expressionToGlsl(context, args[i]);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  },\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,OAAOA,cAAc,MAAM,4BAA4B;AACvD,SAAQC,QAAQ,QAAO,gCAAgC;AACvD,SAAQC,OAAO,EAAEC,UAAU,EAAEC,aAAa,QAAO,aAAa;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,UAAU,GAAG;EACxBC,MAAM,EAAE,OAAO;EACfC,MAAM,EAAE,OAAO;EACfC,KAAK,EAAE,OAAO;EACdC,OAAO,EAAE,OAAO;EAChBC,YAAY,EAAE,OAAO;EACrBC,GAAG,EAAE,OAAO;EACZC,IAAI,EAAE;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAMC,SAAS,GAAG,CAAC,CAAC;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAY,CAACC,KAAK,EAAE;EAClC,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAOV,UAAU,CAACC,MAAM;EAC1B;EACA,IAAI,OAAOS,KAAK,KAAK,SAAS,EAAE;IAC9B,OAAOV,UAAU,CAACI,OAAO;EAC3B;EACA,IAAI,OAAOM,KAAK,KAAK,QAAQ,EAAE;IAC7B,IAAIX,aAAa,CAACW,KAAK,CAAC,EAAE;MACxB,OAAOV,UAAU,CAACG,KAAK,GAAG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"},"metadata":{},"sourceType":"module","externalDependencies":[]}