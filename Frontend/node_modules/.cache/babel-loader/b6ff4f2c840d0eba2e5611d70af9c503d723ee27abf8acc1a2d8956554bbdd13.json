{"ast":null,"code":"/**\n * @module ol/webgl/TileTexture\n */\n\nimport DataTile from '../DataTile.js';\nimport EventTarget from '../events/Target.js';\nimport EventType from '../events/EventType.js';\nimport ImageTile from '../ImageTile.js';\nimport ReprojTile from '../reproj/Tile.js';\nimport TileState from '../TileState.js';\nimport WebGLArrayBuffer from './Buffer.js';\nimport { ARRAY_BUFFER, STATIC_DRAW } from '../webgl.js';\nimport { toSize } from '../size.js';\n\n/**\n * @param {WebGLRenderingContext} gl The WebGL context.\n * @param {WebGLTexture} texture The texture.\n * @param {boolean} interpolate Interpolate when resampling.\n */\nfunction bindAndConfigure(gl, texture, interpolate) {\n  const resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);\n}\n\n/**\n * @param {WebGLRenderingContext} gl The WebGL context.\n * @param {WebGLTexture} texture The texture.\n * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image The image.\n * @param {boolean} interpolate Interpolate when resampling.\n */\nfunction uploadImageTexture(gl, texture, image, interpolate) {\n  bindAndConfigure(gl, texture, interpolate);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n}\n\n/**\n * @param {import(\"./Helper.js\").default} helper The WebGL helper.\n * @param {WebGLTexture} texture The texture.\n * @param {import(\"../DataTile.js\").Data} data The pixel data.\n * @param {import(\"../size.js\").Size} size The pixel size.\n * @param {number} bandCount The band count.\n * @param {boolean} interpolate Interpolate when resampling.\n */\nfunction uploadDataTexture(helper, texture, data, size, bandCount, interpolate) {\n  const gl = helper.getGL();\n  let textureType;\n  let canInterpolate;\n  if (data instanceof Float32Array) {\n    textureType = gl.FLOAT;\n    helper.getExtension('OES_texture_float');\n    const extension = helper.getExtension('OES_texture_float_linear');\n    canInterpolate = extension !== null;\n  } else {\n    textureType = gl.UNSIGNED_BYTE;\n    canInterpolate = true;\n  }\n  bindAndConfigure(gl, texture, interpolate && canInterpolate);\n  const bytesPerRow = data.byteLength / size[1];\n  let unpackAlignment = 1;\n  if (bytesPerRow % 8 === 0) {\n    unpackAlignment = 8;\n  } else if (bytesPerRow % 4 === 0) {\n    unpackAlignment = 4;\n  } else if (bytesPerRow % 2 === 0) {\n    unpackAlignment = 2;\n  }\n  let format;\n  switch (bandCount) {\n    case 1:\n      {\n        format = gl.LUMINANCE;\n        break;\n      }\n    case 2:\n      {\n        format = gl.LUMINANCE_ALPHA;\n        break;\n      }\n    case 3:\n      {\n        format = gl.RGB;\n        break;\n      }\n    case 4:\n      {\n        format = gl.RGBA;\n        break;\n      }\n    default:\n      {\n        throw new Error(`Unsupported number of bands: ${bandCount}`);\n      }\n  }\n  const oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n  gl.texImage2D(gl.TEXTURE_2D, 0, format, size[0], size[1], 0, format, textureType, data);\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);\n}\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet pixelContext = null;\nfunction createPixelContext() {\n  const canvas = document.createElement('canvas');\n  canvas.width = 1;\n  canvas.height = 1;\n  pixelContext = canvas.getContext('2d');\n}\n\n/**\n * @typedef {import(\"../DataTile.js\").default|ImageTile|ReprojTile} TileType\n */\n\n/**\n * @typedef {Object} Options\n * @property {TileType} tile The tile.\n * @property {import(\"../tilegrid/TileGrid.js\").default} grid Tile grid.\n * @property {import(\"../webgl/Helper.js\").default} helper WebGL helper.\n * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.\n */\n\nclass TileTexture extends EventTarget {\n  /**\n   * @param {Options} options The tile texture options.\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * @type {TileType}\n     */\n    this.tile;\n\n    /**\n     * @type {Array<WebGLTexture>}\n     */\n    this.textures = [];\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\n\n    /**\n     * @type {import(\"../size.js\").Size}\n     * @private\n     */\n    this.renderSize_ = toSize(options.grid.getTileSize(options.tile.tileCoord[0]));\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.gutter_ = options.gutter || 0;\n\n    /**\n     * @type {number}\n     */\n    this.bandCount = NaN;\n\n    /**\n     * @type {import(\"../webgl/Helper.js\").default}\n     * @private\n     */\n    this.helper_ = options.helper;\n    const coords = new WebGLArrayBuffer(ARRAY_BUFFER, STATIC_DRAW);\n    coords.fromArray([0,\n    // P0\n    1, 1,\n    // P1\n    1, 1,\n    // P2\n    0, 0,\n    // P3\n    0]);\n    this.helper_.flushBufferData(coords);\n\n    /**\n     * @type {WebGLArrayBuffer}\n     */\n    this.coords = coords;\n    this.setTile(options.tile);\n  }\n\n  /**\n   * @param {TileType} tile Tile.\n   */\n  setTile(tile) {\n    if (tile !== this.tile) {\n      if (this.tile) {\n        this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);\n      }\n      this.tile = tile;\n      this.textures.length = 0;\n      this.loaded = tile.getState() === TileState.LOADED;\n      if (this.loaded) {\n        this.uploadTile_();\n      } else {\n        if (tile instanceof ImageTile) {\n          const image = tile.getImage();\n          if (image instanceof Image && !image.crossOrigin) {\n            image.crossOrigin = 'anonymous';\n          }\n        }\n        tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n      }\n    }\n  }\n  uploadTile_() {\n    const helper = this.helper_;\n    const gl = helper.getGL();\n    const tile = this.tile;\n    if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n      const texture = gl.createTexture();\n      this.textures.push(texture);\n      this.bandCount = 4;\n      uploadImageTexture(gl, texture, tile.getImage(), tile.interpolate);\n      return;\n    }\n    const sourceTileSize = tile.getSize();\n    const pixelSize = [sourceTileSize[0] + 2 * this.gutter_, sourceTileSize[1] + 2 * this.gutter_];\n    const data = tile.getData();\n    const isFloat = data instanceof Float32Array;\n    const pixelCount = pixelSize[0] * pixelSize[1];\n    const DataType = isFloat ? Float32Array : Uint8Array;\n    const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n    const bytesPerRow = data.byteLength / pixelSize[1];\n    this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);\n    const textureCount = Math.ceil(this.bandCount / 4);\n    if (textureCount === 1) {\n      const texture = gl.createTexture();\n      this.textures.push(texture);\n      uploadDataTexture(helper, texture, data, pixelSize, this.bandCount, tile.interpolate);\n      return;\n    }\n    const textureDataArrays = new Array(textureCount);\n    for (let textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\n      const texture = gl.createTexture();\n      this.textures.push(texture);\n      const bandCount = textureIndex < textureCount - 1 ? 4 : (this.bandCount - 1) % 4 + 1;\n      textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);\n    }\n    let dataIndex = 0;\n    let rowOffset = 0;\n    const colCount = pixelSize[0] * this.bandCount;\n    for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\n      for (let colIndex = 0; colIndex < colCount; ++colIndex) {\n        const dataValue = data[rowOffset + colIndex];\n        const pixelIndex = Math.floor(dataIndex / this.bandCount);\n        const bandIndex = colIndex % this.bandCount;\n        const textureIndex = Math.floor(bandIndex / 4);\n        const textureData = textureDataArrays[textureIndex];\n        const bandCount = textureData.length / pixelCount;\n        const textureBandIndex = bandIndex % 4;\n        textureData[pixelIndex * bandCount + textureBandIndex] = dataValue;\n        ++dataIndex;\n      }\n      rowOffset += bytesPerRow / bytesPerElement;\n    }\n    for (let textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\n      const texture = this.textures[textureIndex];\n      const textureData = textureDataArrays[textureIndex];\n      const bandCount = textureData.length / pixelCount;\n      uploadDataTexture(helper, texture, textureData, pixelSize, bandCount, tile.interpolate);\n    }\n  }\n  handleTileChange_() {\n    if (this.tile.getState() === TileState.LOADED) {\n      this.loaded = true;\n      this.uploadTile_();\n      this.dispatchEvent(EventType.CHANGE);\n    }\n  }\n  disposeInternal() {\n    const gl = this.helper_.getGL();\n    this.helper_.deleteBuffer(this.coords);\n    for (let i = 0; i < this.textures.length; ++i) {\n      gl.deleteTexture(this.textures[i]);\n    }\n    this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);\n  }\n\n  /**\n   * Get data for a pixel.  If the tile is not loaded, null is returned.\n   * @param {number} renderCol The column index (in rendered tile space).\n   * @param {number} renderRow The row index (in rendered tile space).\n   * @return {import(\"../DataTile.js\").Data|null} The data.\n   */\n  getPixelData(renderCol, renderRow) {\n    if (!this.loaded) {\n      return null;\n    }\n    const renderWidth = this.renderSize_[0];\n    const renderHeight = this.renderSize_[1];\n    const gutter = this.gutter_;\n    if (this.tile instanceof DataTile) {\n      const sourceSize = this.tile.getSize();\n      const sourceWidthWithoutGutter = sourceSize[0];\n      const sourceHeightWithoutGutter = sourceSize[1];\n      const sourceWidth = sourceWidthWithoutGutter + 2 * gutter;\n      const sourceHeight = sourceHeightWithoutGutter + 2 * gutter;\n      const sourceCol = gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));\n      const sourceRow = gutter + Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));\n      const data = this.tile.getData();\n      if (data instanceof DataView) {\n        const bytesPerPixel = data.byteLength / (sourceWidth * sourceHeight);\n        const offset = bytesPerPixel * (sourceRow * sourceWidth + sourceCol);\n        const buffer = data.buffer.slice(offset, offset + bytesPerPixel);\n        return new DataView(buffer);\n      }\n      const offset = this.bandCount * (sourceRow * sourceWidth + sourceCol);\n      return data.slice(offset, offset + this.bandCount);\n    }\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n    const image = this.tile.getImage();\n    const sourceWidth = image.width;\n    const sourceHeight = image.height;\n    const sourceWidthWithoutGutter = sourceWidth - 2 * gutter;\n    const sourceHeightWithoutGutter = sourceHeight - 2 * gutter;\n    const sourceCol = gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));\n    const sourceRow = gutter + Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));\n    let data;\n    try {\n      pixelContext.drawImage(image, sourceCol, sourceRow, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      pixelContext = null;\n      return null;\n    }\n    return data;\n  }\n}\nexport default TileTexture;","map":{"version":3,"names":["DataTile","EventTarget","EventType","ImageTile","ReprojTile","TileState","WebGLArrayBuffer","ARRAY_BUFFER","STATIC_DRAW","toSize","bindAndConfigure","gl","texture","interpolate","resampleFilter","LINEAR","NEAREST","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","uploadImageTexture","image","texImage2D","RGBA","UNSIGNED_BYTE","uploadDataTexture","helper","data","size","bandCount","getGL","textureType","canInterpolate","Float32Array","FLOAT","getExtension","extension","bytesPerRow","byteLength","unpackAlignment","format","LUMINANCE","LUMINANCE_ALPHA","RGB","Error","oldUnpackAlignment","getParameter","UNPACK_ALIGNMENT","pixelStorei","pixelContext","createPixelContext","canvas","document","createElement","width","height","getContext","TileTexture","constructor","options","tile","textures","handleTileChange_","bind","renderSize_","grid","getTileSize","tileCoord","gutter_","gutter","NaN","helper_","coords","fromArray","flushBufferData","setTile","removeEventListener","CHANGE","length","loaded","getState","LOADED","uploadTile_","getImage","Image","crossOrigin","addEventListener","createTexture","push","sourceTileSize","getSize","pixelSize","getData","isFloat","pixelCount","DataType","Uint8Array","bytesPerElement","BYTES_PER_ELEMENT","Math","floor","textureCount","ceil","textureDataArrays","Array","textureIndex","dataIndex","rowOffset","colCount","rowIndex","colIndex","dataValue","pixelIndex","bandIndex","textureData","textureBandIndex","dispatchEvent","disposeInternal","deleteBuffer","i","deleteTexture","getPixelData","renderCol","renderRow","renderWidth","renderHeight","sourceSize","sourceWidthWithoutGutter","sourceHeightWithoutGutter","sourceWidth","sourceHeight","sourceCol","sourceRow","DataView","bytesPerPixel","offset","buffer","slice","clearRect","drawImage","getImageData","err"],"sources":["/Users/lydiaprice/quake-text/Frontend/node_modules/ol/webgl/TileTexture.js"],"sourcesContent":["/**\n * @module ol/webgl/TileTexture\n */\n\nimport DataTile from '../DataTile.js';\nimport EventTarget from '../events/Target.js';\nimport EventType from '../events/EventType.js';\nimport ImageTile from '../ImageTile.js';\nimport ReprojTile from '../reproj/Tile.js';\nimport TileState from '../TileState.js';\nimport WebGLArrayBuffer from './Buffer.js';\nimport {ARRAY_BUFFER, STATIC_DRAW} from '../webgl.js';\nimport {toSize} from '../size.js';\n\n/**\n * @param {WebGLRenderingContext} gl The WebGL context.\n * @param {WebGLTexture} texture The texture.\n * @param {boolean} interpolate Interpolate when resampling.\n */\nfunction bindAndConfigure(gl, texture, interpolate) {\n  const resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);\n}\n\n/**\n * @param {WebGLRenderingContext} gl The WebGL context.\n * @param {WebGLTexture} texture The texture.\n * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image The image.\n * @param {boolean} interpolate Interpolate when resampling.\n */\nfunction uploadImageTexture(gl, texture, image, interpolate) {\n  bindAndConfigure(gl, texture, interpolate);\n\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n}\n\n/**\n * @param {import(\"./Helper.js\").default} helper The WebGL helper.\n * @param {WebGLTexture} texture The texture.\n * @param {import(\"../DataTile.js\").Data} data The pixel data.\n * @param {import(\"../size.js\").Size} size The pixel size.\n * @param {number} bandCount The band count.\n * @param {boolean} interpolate Interpolate when resampling.\n */\nfunction uploadDataTexture(\n  helper,\n  texture,\n  data,\n  size,\n  bandCount,\n  interpolate\n) {\n  const gl = helper.getGL();\n  let textureType;\n  let canInterpolate;\n  if (data instanceof Float32Array) {\n    textureType = gl.FLOAT;\n    helper.getExtension('OES_texture_float');\n    const extension = helper.getExtension('OES_texture_float_linear');\n    canInterpolate = extension !== null;\n  } else {\n    textureType = gl.UNSIGNED_BYTE;\n    canInterpolate = true;\n  }\n  bindAndConfigure(gl, texture, interpolate && canInterpolate);\n\n  const bytesPerRow = data.byteLength / size[1];\n  let unpackAlignment = 1;\n  if (bytesPerRow % 8 === 0) {\n    unpackAlignment = 8;\n  } else if (bytesPerRow % 4 === 0) {\n    unpackAlignment = 4;\n  } else if (bytesPerRow % 2 === 0) {\n    unpackAlignment = 2;\n  }\n\n  let format;\n  switch (bandCount) {\n    case 1: {\n      format = gl.LUMINANCE;\n      break;\n    }\n    case 2: {\n      format = gl.LUMINANCE_ALPHA;\n      break;\n    }\n    case 3: {\n      format = gl.RGB;\n      break;\n    }\n    case 4: {\n      format = gl.RGBA;\n      break;\n    }\n    default: {\n      throw new Error(`Unsupported number of bands: ${bandCount}`);\n    }\n  }\n\n  const oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    0,\n    format,\n    size[0],\n    size[1],\n    0,\n    format,\n    textureType,\n    data\n  );\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);\n}\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet pixelContext = null;\n\nfunction createPixelContext() {\n  const canvas = document.createElement('canvas');\n  canvas.width = 1;\n  canvas.height = 1;\n  pixelContext = canvas.getContext('2d');\n}\n\n/**\n * @typedef {import(\"../DataTile.js\").default|ImageTile|ReprojTile} TileType\n */\n\n/**\n * @typedef {Object} Options\n * @property {TileType} tile The tile.\n * @property {import(\"../tilegrid/TileGrid.js\").default} grid Tile grid.\n * @property {import(\"../webgl/Helper.js\").default} helper WebGL helper.\n * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.\n */\n\nclass TileTexture extends EventTarget {\n  /**\n   * @param {Options} options The tile texture options.\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * @type {TileType}\n     */\n    this.tile;\n\n    /**\n     * @type {Array<WebGLTexture>}\n     */\n    this.textures = [];\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\n\n    /**\n     * @type {import(\"../size.js\").Size}\n     * @private\n     */\n    this.renderSize_ = toSize(\n      options.grid.getTileSize(options.tile.tileCoord[0])\n    );\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.gutter_ = options.gutter || 0;\n\n    /**\n     * @type {number}\n     */\n    this.bandCount = NaN;\n\n    /**\n     * @type {import(\"../webgl/Helper.js\").default}\n     * @private\n     */\n    this.helper_ = options.helper;\n\n    const coords = new WebGLArrayBuffer(ARRAY_BUFFER, STATIC_DRAW);\n    coords.fromArray([\n      0, // P0\n      1,\n      1, // P1\n      1,\n      1, // P2\n      0,\n      0, // P3\n      0,\n    ]);\n    this.helper_.flushBufferData(coords);\n\n    /**\n     * @type {WebGLArrayBuffer}\n     */\n    this.coords = coords;\n\n    this.setTile(options.tile);\n  }\n\n  /**\n   * @param {TileType} tile Tile.\n   */\n  setTile(tile) {\n    if (tile !== this.tile) {\n      if (this.tile) {\n        this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);\n      }\n      this.tile = tile;\n      this.textures.length = 0;\n      this.loaded = tile.getState() === TileState.LOADED;\n      if (this.loaded) {\n        this.uploadTile_();\n      } else {\n        if (tile instanceof ImageTile) {\n          const image = tile.getImage();\n          if (image instanceof Image && !image.crossOrigin) {\n            image.crossOrigin = 'anonymous';\n          }\n        }\n        tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n      }\n    }\n  }\n\n  uploadTile_() {\n    const helper = this.helper_;\n    const gl = helper.getGL();\n    const tile = this.tile;\n\n    if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n      const texture = gl.createTexture();\n      this.textures.push(texture);\n      this.bandCount = 4;\n      uploadImageTexture(gl, texture, tile.getImage(), tile.interpolate);\n      return;\n    }\n\n    const sourceTileSize = tile.getSize();\n    const pixelSize = [\n      sourceTileSize[0] + 2 * this.gutter_,\n      sourceTileSize[1] + 2 * this.gutter_,\n    ];\n    const data = tile.getData();\n    const isFloat = data instanceof Float32Array;\n    const pixelCount = pixelSize[0] * pixelSize[1];\n    const DataType = isFloat ? Float32Array : Uint8Array;\n    const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n    const bytesPerRow = data.byteLength / pixelSize[1];\n\n    this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);\n    const textureCount = Math.ceil(this.bandCount / 4);\n\n    if (textureCount === 1) {\n      const texture = gl.createTexture();\n      this.textures.push(texture);\n      uploadDataTexture(\n        helper,\n        texture,\n        data,\n        pixelSize,\n        this.bandCount,\n        tile.interpolate\n      );\n      return;\n    }\n\n    const textureDataArrays = new Array(textureCount);\n    for (let textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\n      const texture = gl.createTexture();\n      this.textures.push(texture);\n\n      const bandCount =\n        textureIndex < textureCount - 1 ? 4 : ((this.bandCount - 1) % 4) + 1;\n      textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);\n    }\n\n    let dataIndex = 0;\n    let rowOffset = 0;\n    const colCount = pixelSize[0] * this.bandCount;\n    for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\n      for (let colIndex = 0; colIndex < colCount; ++colIndex) {\n        const dataValue = data[rowOffset + colIndex];\n\n        const pixelIndex = Math.floor(dataIndex / this.bandCount);\n        const bandIndex = colIndex % this.bandCount;\n        const textureIndex = Math.floor(bandIndex / 4);\n        const textureData = textureDataArrays[textureIndex];\n        const bandCount = textureData.length / pixelCount;\n        const textureBandIndex = bandIndex % 4;\n        textureData[pixelIndex * bandCount + textureBandIndex] = dataValue;\n\n        ++dataIndex;\n      }\n      rowOffset += bytesPerRow / bytesPerElement;\n    }\n\n    for (let textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\n      const texture = this.textures[textureIndex];\n      const textureData = textureDataArrays[textureIndex];\n      const bandCount = textureData.length / pixelCount;\n      uploadDataTexture(\n        helper,\n        texture,\n        textureData,\n        pixelSize,\n        bandCount,\n        tile.interpolate\n      );\n    }\n  }\n\n  handleTileChange_() {\n    if (this.tile.getState() === TileState.LOADED) {\n      this.loaded = true;\n      this.uploadTile_();\n      this.dispatchEvent(EventType.CHANGE);\n    }\n  }\n\n  disposeInternal() {\n    const gl = this.helper_.getGL();\n    this.helper_.deleteBuffer(this.coords);\n    for (let i = 0; i < this.textures.length; ++i) {\n      gl.deleteTexture(this.textures[i]);\n    }\n    this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);\n  }\n\n  /**\n   * Get data for a pixel.  If the tile is not loaded, null is returned.\n   * @param {number} renderCol The column index (in rendered tile space).\n   * @param {number} renderRow The row index (in rendered tile space).\n   * @return {import(\"../DataTile.js\").Data|null} The data.\n   */\n  getPixelData(renderCol, renderRow) {\n    if (!this.loaded) {\n      return null;\n    }\n    const renderWidth = this.renderSize_[0];\n    const renderHeight = this.renderSize_[1];\n    const gutter = this.gutter_;\n\n    if (this.tile instanceof DataTile) {\n      const sourceSize = this.tile.getSize();\n\n      const sourceWidthWithoutGutter = sourceSize[0];\n      const sourceHeightWithoutGutter = sourceSize[1];\n      const sourceWidth = sourceWidthWithoutGutter + 2 * gutter;\n      const sourceHeight = sourceHeightWithoutGutter + 2 * gutter;\n\n      const sourceCol =\n        gutter +\n        Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));\n\n      const sourceRow =\n        gutter +\n        Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));\n\n      const data = this.tile.getData();\n      if (data instanceof DataView) {\n        const bytesPerPixel = data.byteLength / (sourceWidth * sourceHeight);\n        const offset = bytesPerPixel * (sourceRow * sourceWidth + sourceCol);\n        const buffer = data.buffer.slice(offset, offset + bytesPerPixel);\n        return new DataView(buffer);\n      }\n\n      const offset = this.bandCount * (sourceRow * sourceWidth + sourceCol);\n      return data.slice(offset, offset + this.bandCount);\n    }\n\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n\n    const image = this.tile.getImage();\n    const sourceWidth = image.width;\n    const sourceHeight = image.height;\n\n    const sourceWidthWithoutGutter = sourceWidth - 2 * gutter;\n    const sourceHeightWithoutGutter = sourceHeight - 2 * gutter;\n\n    const sourceCol =\n      gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));\n\n    const sourceRow =\n      gutter +\n      Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));\n\n    let data;\n    try {\n      pixelContext.drawImage(image, sourceCol, sourceRow, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      pixelContext = null;\n      return null;\n    }\n    return data;\n  }\n}\n\nexport default TileTexture;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}