{"ast":null,"code":"/**\n * @module ol/format/XMLFeature\n */\nimport FeatureFormat from '../format/Feature.js';\nimport { abstract } from '../util.js';\nimport { extend } from '../array.js';\nimport { getXMLSerializer, isDocument, parse } from '../xml.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for XML feature formats.\n *\n * @abstract\n */\nclass XMLFeature extends FeatureFormat {\n  constructor() {\n    super();\n\n    /**\n     * @type {XMLSerializer}\n     * @private\n     */\n    this.xmlSerializer_ = getXMLSerializer();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return 'xml';\n  }\n\n  /**\n   * Read a single feature.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readFeatureFromDocument( /** @type {Document} */source, options);\n    } else {\n      return this.readFeatureFromNode( /** @type {Element} */source, options);\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromDocument(doc, options) {\n    const features = this.readFeaturesFromDocument(doc, options);\n    if (features.length > 0) {\n      return features[0];\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read all features from a feature collection.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, options) {\n    if (!source) {\n      return [];\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeaturesFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readFeaturesFromDocument( /** @type {Document} */source, options);\n    } else {\n      return this.readFeaturesFromNode( /** @type {Element} */source, options);\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromDocument(doc, options) {\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    const features = [];\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(features, this.readFeaturesFromNode( /** @type {Element} */n, options));\n      }\n    }\n    return features;\n  }\n\n  /**\n   * @abstract\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readGeometryFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readGeometryFromDocument( /** @type {Document} */source, options);\n    } else {\n      return this.readGeometryFromNode( /** @type {Element} */source, options);\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromDocument(doc, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read the projection from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   */\n  readProjection(source) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readProjectionFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readProjectionFromDocument( /** @type {Document} */source);\n    } else {\n      return this.readProjectionFromNode( /** @type {Element} */source);\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    return this.dataProjection;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    return this.dataProjection;\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   */\n  writeFeature(feature, options) {\n    const node = this.writeFeatureNode(feature, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @protected\n   * @return {Node} Node.\n   */\n  writeFeatureNode(feature, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Result.\n   * @api\n   */\n  writeFeatures(features, options) {\n    const node = this.writeFeaturesNode(features, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeFeaturesNode(features, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   */\n  writeGeometry(geometry, options) {\n    const node = this.writeGeometryNode(geometry, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeGeometryNode(geometry, options) {\n    return null; // not implemented\n  }\n}\n\nexport default XMLFeature;","map":{"version":3,"names":["FeatureFormat","abstract","extend","getXMLSerializer","isDocument","parse","XMLFeature","constructor","xmlSerializer_","getType","readFeature","source","options","doc","readFeatureFromDocument","readFeatureFromNode","features","readFeaturesFromDocument","length","node","readFeatures","readFeaturesFromNode","n","firstChild","nextSibling","nodeType","Node","ELEMENT_NODE","readGeometry","readGeometryFromDocument","readGeometryFromNode","readProjection","readProjectionFromDocument","readProjectionFromNode","dataProjection","writeFeature","feature","writeFeatureNode","serializeToString","writeFeatures","writeFeaturesNode","writeGeometry","geometry","writeGeometryNode"],"sources":["/Users/lydiaprice/quake-text/Frontend/node_modules/ol/format/XMLFeature.js"],"sourcesContent":["/**\n * @module ol/format/XMLFeature\n */\nimport FeatureFormat from '../format/Feature.js';\nimport {abstract} from '../util.js';\nimport {extend} from '../array.js';\nimport {getXMLSerializer, isDocument, parse} from '../xml.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for XML feature formats.\n *\n * @abstract\n */\nclass XMLFeature extends FeatureFormat {\n  constructor() {\n    super();\n\n    /**\n     * @type {XMLSerializer}\n     * @private\n     */\n    this.xmlSerializer_ = getXMLSerializer();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return 'xml';\n  }\n\n  /**\n   * Read a single feature.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readFeatureFromDocument(\n        /** @type {Document} */ (source),\n        options\n      );\n    } else {\n      return this.readFeatureFromNode(/** @type {Element} */ (source), options);\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromDocument(doc, options) {\n    const features = this.readFeaturesFromDocument(doc, options);\n    if (features.length > 0) {\n      return features[0];\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read all features from a feature collection.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, options) {\n    if (!source) {\n      return [];\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeaturesFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readFeaturesFromDocument(\n        /** @type {Document} */ (source),\n        options\n      );\n    } else {\n      return this.readFeaturesFromNode(\n        /** @type {Element} */ (source),\n        options\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromDocument(doc, options) {\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    const features = [];\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(\n          features,\n          this.readFeaturesFromNode(/** @type {Element} */ (n), options)\n        );\n      }\n    }\n    return features;\n  }\n\n  /**\n   * @abstract\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, options) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readGeometryFromDocument(doc, options);\n    } else if (isDocument(source)) {\n      return this.readGeometryFromDocument(\n        /** @type {Document} */ (source),\n        options\n      );\n    } else {\n      return this.readGeometryFromNode(\n        /** @type {Element} */ (source),\n        options\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromDocument(doc, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromNode(node, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Read the projection from the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   */\n  readProjection(source) {\n    if (!source) {\n      return null;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readProjectionFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readProjectionFromDocument(/** @type {Document} */ (source));\n    } else {\n      return this.readProjectionFromNode(/** @type {Element} */ (source));\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    return this.dataProjection;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    return this.dataProjection;\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   */\n  writeFeature(feature, options) {\n    const node = this.writeFeatureNode(feature, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @protected\n   * @return {Node} Node.\n   */\n  writeFeatureNode(feature, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Result.\n   * @api\n   */\n  writeFeatures(features, options) {\n    const node = this.writeFeaturesNode(features, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeFeaturesNode(features, options) {\n    return null; // not implemented\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   */\n  writeGeometry(geometry, options) {\n    const node = this.writeGeometryNode(geometry, options);\n    return this.xmlSerializer_.serializeToString(node);\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   */\n  writeGeometryNode(geometry, options) {\n    return null; // not implemented\n  }\n}\n\nexport default XMLFeature;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}