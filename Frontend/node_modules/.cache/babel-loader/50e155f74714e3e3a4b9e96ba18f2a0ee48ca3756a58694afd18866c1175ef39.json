{"ast":null,"code":"/**\n * @module ol/renderer/webgl/TileLayer\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport TileTexture from '../../webgl/TileTexture.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport { AttributeType } from '../../webgl/Helper.js';\nimport { ELEMENT_ARRAY_BUFFER, STATIC_DRAW } from '../../webgl.js';\nimport { apply as applyTransform, create as createTransform, reset as resetTransform, rotate as rotateTransform, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\nimport { boundingExtent, containsCoordinate, getIntersection, isEmpty } from '../../extent.js';\nimport { create as createMat4, fromTransform as mat4FromTransform } from '../../vec/mat4.js';\nimport { createOrUpdate as createTileCoord, getKey as getTileCoordKey } from '../../tilecoord.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { toSize } from '../../size.js';\nexport const Uniforms = {\n  TILE_TEXTURE_ARRAY: 'u_tileTextures',\n  TILE_TRANSFORM: 'u_tileTransform',\n  TRANSITION_ALPHA: 'u_transitionAlpha',\n  DEPTH: 'u_depth',\n  TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',\n  TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',\n  TEXTURE_RESOLUTION: 'u_textureResolution',\n  // map units per texture pixel\n  TEXTURE_ORIGIN_X: 'u_textureOriginX',\n  // map x coordinate of left edge of texture\n  TEXTURE_ORIGIN_Y: 'u_textureOriginY',\n  // map y coordinate of top edge of texture\n  RENDER_EXTENT: 'u_renderExtent',\n  // intersection of layer, source, and view extent\n  RESOLUTION: 'u_resolution',\n  ZOOM: 'u_zoom'\n};\nexport const Attributes = {\n  TEXTURE_COORD: 'a_textureCoord'\n};\n\n/**\n * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n */\nconst attributeDescriptions = [{\n  name: Attributes.TEXTURE_COORD,\n  size: 2,\n  type: AttributeType.FLOAT\n}];\n\n/**\n * @type {Object<string, boolean>}\n */\nconst empty = {};\n\n/**\n * Transform a zoom level into a depth value ranging from -1 to 1.\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\nfunction depthForZ(z) {\n  return 2 * (1 - 1 / (z + 1)) - 1;\n}\n\n/**\n * Add a tile texture to the lookup.\n * @param {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>} tileTexturesByZ Lookup of\n * tile textures by zoom level.\n * @param {import(\"../../webgl/TileTexture.js\").default} tileTexture A tile texture.\n * @param {number} z The zoom level.\n */\nfunction addTileTextureToLookup(tileTexturesByZ, tileTexture, z) {\n  if (!(z in tileTexturesByZ)) {\n    tileTexturesByZ[z] = [];\n  }\n  tileTexturesByZ[z].push(tileTexture);\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */\n  layerState.layer.getRenderSource();\n  if (!source.getWrapX()) {\n    const gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\nfunction getCacheKey(source, tileCoord) {\n  return `${source.getKey()},${getTileCoordKey(tileCoord)}`;\n}\n\n/**\n * @typedef {Object} Options\n * @property {string} vertexShader Vertex shader source.\n * @property {string} fragmentShader Fragment shader source.\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {Array<import(\"../../webgl/PaletteTexture.js\").default>} [paletteTextures] Palette textures.\n * @property {number} [cacheSize=512] The texture cache size.\n */\n\n/**\n * @typedef {import(\"../../layer/WebGLTile.js\").default} LayerType\n */\n\n/**\n * @classdesc\n * WebGL renderer for tile layers.\n * @extends {WebGLLayerRenderer<LayerType>}\n * @api\n */\nclass WebGLTileLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, {\n      uniforms: options.uniforms\n    });\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * This transform converts texture coordinates to screen coordinates.\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.tileTransform_ = createTransform();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.tempMat4_ = createMat4();\n\n    /**\n     * @type {import(\"../../TileRange.js\").default}\n     * @private\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    /**\n     * @type {import(\"../../size.js\").Size}\n     * @private\n     */\n    this.tempSize_ = [0, 0];\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * Tiles are rendered as a quad with the following structure:\n     *\n     *  [P3]---------[P2]\n     *   |`           |\n     *   |  `     B   |\n     *   |    `       |\n     *   |      `     |\n     *   |   A    `   |\n     *   |          ` |\n     *  [P0]---------[P1]\n     *\n     * Triangle A: P0, P1, P3\n     * Triangle B: P1, P2, P3\n     *\n     * @private\n     */\n    this.indices_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\n    this.indices_.fromArray([0, 1, 3, 1, 2, 3]);\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../webgl/TileTexture.js\").default>}\n     * @private\n     */\n    this.tileTextureCache_ = new LRUCache(cacheSize);\n\n    /**\n     * @type {Array<import(\"../../webgl/PaletteTexture.js\").default>}\n     * @private\n     */\n    this.paletteTextures_ = options.paletteTextures || [];\n\n    /**\n     * @private\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.projection_ = undefined;\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset({\n      uniforms: options.uniforms\n    });\n    this.vertexShader_ = options.vertexShader;\n    this.fragmentShader_ = options.fragmentShader;\n    this.paletteTextures_ = options.paletteTextures || [];\n    if (this.helper) {\n      this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n    }\n  }\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n    this.helper.flushBufferData(this.indices_);\n  }\n\n  /**\n   * @param {import(\"../../webgl/TileTexture\").TileType} tile Tile.\n   * @return {boolean} Tile is drawable.\n   * @private\n   */\n  isDrawableTile_(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    if (!this.projection_) {\n      this.projection_ = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.projection_) {\n      this.clearCache();\n      this.projection_ = frameState.viewState.projection;\n    }\n    const layer = this.getLayer();\n    const source = layer.getRenderSource();\n    if (!source) {\n      return false;\n    }\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n      return false;\n    }\n    return source.getState() === 'ready';\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {Object<number, Array<TileTexture>>} tileTexturesByZ The zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tileTexturesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileTextureCache = this.tileTextureCache_;\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(initialZ - preload, tileGrid.getMinZoom(), tileGrid.getZForResolution(Math.min(tileLayer.getMaxResolution(), map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)), tileSource.zDirection));\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);\n      const tileResolution = tileGrid.getResolution(z);\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n          const cacheKey = getCacheKey(tileSource, tileCoord);\n\n          /** @type {TileTexture} */\n          let tileTexture;\n\n          /** @type {import(\"../../webgl/TileTexture\").TileType} */\n          let tile;\n          if (tileTextureCache.containsKey(cacheKey)) {\n            tileTexture = tileTextureCache.get(cacheKey);\n            tile = tileTexture.tile;\n          }\n          if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {\n            tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);\n            if (!tileTexture) {\n              tileTexture = new TileTexture({\n                tile: tile,\n                grid: tileGrid,\n                helper: this.helper,\n                gutter: gutter\n              });\n              tileTextureCache.set(cacheKey, tileTexture);\n            } else {\n              if (this.isDrawableTile_(tile)) {\n                tileTexture.setTile(tile);\n              } else {\n                const interimTile = /** @type {import(\"../../webgl/TileTexture\").TileType} */\n                tile.getInterimTile();\n                tileTexture.setTile(interimTile);\n              }\n            }\n          }\n          addTileTextureToLookup(tileTexturesByZ, tileTexture, z);\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              frameState.tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tileCoord), tileResolution]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    this.frameState_ = frameState;\n    this.renderComplete = true;\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const extent = getRenderExtent(frameState, frameState.extent);\n    const z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);\n\n    /**\n     * @type {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>}\n     */\n    const tileTexturesByZ = {};\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tileTexturesByZ, preload);\n    }\n    this.enqueueTiles(frameState, extent, z, tileTexturesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(frameState, extent, z - 1, tileTexturesByZ, preload - 1);\n      }, 0);\n    }\n\n    /**\n     * A lookup of alpha values for tiles at the target rendering resolution\n     * for tiles that are in transition.  If a tile coord key is absent from\n     * this lookup, the tile should be rendered at alpha 1.\n     * @type {Object<string, number>}\n     */\n    const alphaLookup = {};\n    const uid = getUid(this);\n    const time = frameState.time;\n    let blend = false;\n\n    // look for cached tiles to use if a target tile is not ready\n    const tileTextures = tileTexturesByZ[z];\n    for (let i = 0, ii = tileTextures.length; i < ii; ++i) {\n      const tileTexture = tileTextures[i];\n      const tile = tileTexture.tile;\n      if (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n      if (tileTexture.loaded) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n        blend = true;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        alphaLookup[tileCoordKey] = alpha;\n      }\n      this.renderComplete = false;\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tileTexturesByZ);\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileTexturesByZ);\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState, !blend);\n    const zs = Object.keys(tileTexturesByZ).map(Number).sort(numberSafeCompareFunction);\n    const centerX = viewState.center[0];\n    const centerY = viewState.center[1];\n    for (let j = 0, jj = zs.length; j < jj; ++j) {\n      const tileZ = zs[j];\n      const tileResolution = tileGrid.getResolution(tileZ);\n      const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n      const tileOrigin = tileGrid.getOrigin(tileZ);\n      const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n      const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n      const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\n      const centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n      const centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n      const tileScale = viewState.resolution / tileResolution;\n      const depth = depthForZ(tileZ);\n      const tileTextures = tileTexturesByZ[tileZ];\n      for (let i = 0, ii = tileTextures.length; i < ii; ++i) {\n        const tileTexture = tileTextures[i];\n        if (!tileTexture.loaded) {\n          continue;\n        }\n        const tile = tileTexture.tile;\n        const tileCoord = tile.tileCoord;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        const tileCenterI = tileCoord[1];\n        const tileCenterJ = tileCoord[2];\n        resetTransform(this.tileTransform_);\n        scaleTransform(this.tileTransform_, 2 / (frameState.size[0] * tileScale / tileWidthWithGutter), -2 / (frameState.size[1] * tileScale / tileWidthWithGutter));\n        rotateTransform(this.tileTransform_, viewState.rotation);\n        scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\n        translateTransform(this.tileTransform_, (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter, (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter);\n        this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, mat4FromTransform(this.tempMat4_, this.tileTransform_));\n        this.helper.bindBuffer(tileTexture.coords);\n        this.helper.bindBuffer(this.indices_);\n        this.helper.enableAttributes(attributeDescriptions);\n        let textureSlot = 0;\n        while (textureSlot < tileTexture.textures.length) {\n          const textureProperty = 'TEXTURE' + textureSlot;\n          const uniformName = `${Uniforms.TILE_TEXTURE_ARRAY}[${textureSlot}]`;\n          gl.activeTexture(gl[textureProperty]);\n          gl.bindTexture(gl.TEXTURE_2D, tileTexture.textures[textureSlot]);\n          gl.uniform1i(this.helper.getUniformLocation(uniformName), textureSlot);\n          ++textureSlot;\n        }\n        for (let paletteIndex = 0; paletteIndex < this.paletteTextures_.length; ++paletteIndex) {\n          const paletteTexture = this.paletteTextures_[paletteIndex];\n          gl.activeTexture(gl['TEXTURE' + textureSlot]);\n          const texture = paletteTexture.getTexture(gl);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          gl.uniform1i(this.helper.getUniformLocation(paletteTexture.name), textureSlot);\n          ++textureSlot;\n        }\n        const alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n        if (alpha < 1) {\n          frameState.animate = true;\n        }\n        this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\n        this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileWidthWithGutter);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileHeightWithGutter);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_RESOLUTION, tileResolution);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_X, tileOrigin[0] + tileCenterI * tileSize[0] * tileResolution - gutter * tileResolution);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_Y, tileOrigin[1] - tileCenterJ * tileSize[1] * tileResolution + gutter * tileResolution);\n        let gutterExtent = extent;\n        if (gutter > 0) {\n          gutterExtent = tileGrid.getTileCoordExtent(tileCoord);\n          getIntersection(gutterExtent, extent, gutterExtent);\n        }\n        this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);\n        this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);\n        this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\n        this.helper.drawElements(0, this.indices_.getSize());\n      }\n    }\n    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n    const canvas = this.helper.getCanvas();\n    const tileTextureCache = this.tileTextureCache_;\n    while (tileTextureCache.canExpireCache()) {\n      const tileTexture = tileTextureCache.pop();\n      tileTexture.dispose();\n    }\n\n    // TODO: let the renderers manage their own cache instead of managing the source cache\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = function (map, frameState) {\n      tileSource.updateCacheSize(0.1, frameState.viewState.projection);\n      tileSource.expireCache(frameState.viewState.projection, empty);\n    };\n    frameState.postRenderFunctions.push(postRenderFunction);\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.\n   */\n  getData(pixel) {\n    const gl = this.helper.getGL();\n    if (!gl) {\n      return null;\n    }\n    const frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    }\n    const layer = this.getLayer();\n    const coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    const viewState = frameState.viewState;\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(fromUserExtent(layerExtent, viewState.projection), coordinate)) {\n        return null;\n      }\n    }\n\n    // determine last source suitable for rendering at coordinate\n    const sources = layer.getSources(boundingExtent([coordinate]), viewState.resolution);\n    let i, source, tileGrid;\n    for (i = sources.length - 1; i >= 0; --i) {\n      source = sources[i];\n      if (source.getState() === 'ready') {\n        tileGrid = source.getTileGridForProjection(viewState.projection);\n        if (source.getWrapX()) {\n          break;\n        }\n        const gridExtent = tileGrid.getExtent();\n        if (!gridExtent || containsCoordinate(gridExtent, coordinate)) {\n          break;\n        }\n      }\n    }\n    if (i < 0) {\n      return null;\n    }\n    const tileTextureCache = this.tileTextureCache_;\n    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const cacheKey = getCacheKey(source, tileCoord);\n      if (!tileTextureCache.containsKey(cacheKey)) {\n        continue;\n      }\n      const tileTexture = tileTextureCache.get(cacheKey);\n      const tile = tileTexture.tile;\n      if (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY) {\n        return null;\n      }\n      if (!tileTexture.loaded) {\n        continue;\n      }\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n      const col = (coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0];\n      const row = (tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1];\n      return tileTexture.getPixelData(col, row);\n    }\n    return null;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>} tileTexturesByZ Lookup of\n   * tile textures by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tileTexturesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);\n    if (!tileRange) {\n      return false;\n    }\n    let covered = true;\n    const tileTextureCache = this.tileTextureCache_;\n    const source = this.getLayer().getRenderSource();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, [altZ, x, y]);\n        let loaded = false;\n        if (tileTextureCache.containsKey(cacheKey)) {\n          const tileTexture = tileTextureCache.get(cacheKey);\n          if (tileTexture.loaded) {\n            addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n  clearCache() {\n    const tileTextureCache = this.tileTextureCache_;\n    tileTextureCache.forEach(tileTexture => tileTexture.dispose());\n    tileTextureCache.clear();\n  }\n  removeHelper() {\n    if (this.helper) {\n      this.clearCache();\n    }\n    super.removeHelper();\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    const helper = this.helper;\n    if (helper) {\n      const gl = helper.getGL();\n      gl.deleteProgram(this.program_);\n      delete this.program_;\n      helper.deleteBuffer(this.indices_);\n    }\n    super.disposeInternal();\n    delete this.indices_;\n    delete this.tileTextureCache_;\n    delete this.frameState_;\n  }\n}\nexport default WebGLTileLayerRenderer;","map":{"version":3,"names":["LRUCache","ReprojTile","TileRange","TileState","TileTexture","WebGLArrayBuffer","WebGLLayerRenderer","AttributeType","ELEMENT_ARRAY_BUFFER","STATIC_DRAW","apply","applyTransform","create","createTransform","reset","resetTransform","rotate","rotateTransform","scale","scaleTransform","translate","translateTransform","boundingExtent","containsCoordinate","getIntersection","isEmpty","createMat4","fromTransform","mat4FromTransform","createOrUpdate","createTileCoord","getKey","getTileCoordKey","fromUserExtent","getUid","numberSafeCompareFunction","toSize","Uniforms","TILE_TEXTURE_ARRAY","TILE_TRANSFORM","TRANSITION_ALPHA","DEPTH","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","TEXTURE_RESOLUTION","TEXTURE_ORIGIN_X","TEXTURE_ORIGIN_Y","RENDER_EXTENT","RESOLUTION","ZOOM","Attributes","TEXTURE_COORD","attributeDescriptions","name","size","type","FLOAT","empty","depthForZ","z","addTileTextureToLookup","tileTexturesByZ","tileTexture","push","getRenderExtent","frameState","extent","layerState","layerStatesArray","layerIndex","viewState","projection","source","layer","getRenderSource","getWrapX","gridExtent","getTileGridForProjection","getExtent","getCacheKey","tileCoord","WebGLTileLayerRenderer","constructor","tileLayer","options","uniforms","renderComplete","tileTransform_","tempMat4_","tempTileRange_","tempTileCoord_","tempSize_","program_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","indices_","fromArray","cacheSize","undefined","tileTextureCache_","paletteTextures_","paletteTextures","frameState_","projection_","helper","getProgram","afterHelperCreated","flushBufferData","isDrawableTile_","tile","getLayer","tileState","getState","useInterimTilesOnError","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","prepareFrameInternal","clearCache","enqueueTiles","initialZ","preload","tileSource","tileGrid","gutter","getGutterForProjection","tileSourceKey","wantedTiles","tileTextureCache","map","getMapInternal","minZ","Math","max","getMinZoom","getZForResolution","min","getMaxResolution","getView","getResolutionForZoom","getResolution","zDirection","tileRange","getTileRangeForExtentAndZ","tileResolution","x","minX","maxX","y","minY","maxY","cacheKey","containsKey","get","key","getTile","pixelRatio","grid","set","setTile","interimTile","getInterimTile","tileQueueKey","IDLE","tileQueue","isKeyQueued","enqueue","getTileCoordCenter","renderFrame","gl","getGL","preRender","resolution","getPreload","nextExtent","targetZ","nextResolution","setTimeout","alphaLookup","uid","time","blend","tileTextures","i","ii","length","loaded","alpha","getAlpha","endTransition","tileCoordKey","coveredByChildren","findAltTiles_","minZoom","parentZ","coveredByParent","useProgram","prepareDraw","zs","Object","keys","Number","sort","centerX","center","centerY","j","jj","tileZ","tileSize","getTileSize","tileOrigin","getOrigin","tileWidthWithGutter","tileHeightWithGutter","aspectRatio","centerI","centerJ","tileScale","depth","tileCenterI","tileCenterJ","rotation","setUniformMatrixValue","bindBuffer","coords","enableAttributes","textureSlot","textures","textureProperty","uniformName","activeTexture","bindTexture","TEXTURE_2D","uniform1i","getUniformLocation","paletteIndex","paletteTexture","texture","getTexture","animate","setUniformFloatValue","gutterExtent","getTileCoordExtent","setUniformFloatVec4","zoom","drawElements","getSize","finalizeDraw","dispatchPreComposeEvent","dispatchPostComposeEvent","canvas","getCanvas","canExpireCache","pop","dispose","postRenderFunction","updateCacheSize","expireCache","postRenderFunctions","postRender","getData","pixel","coordinate","pixelToCoordinateTransform","slice","layerExtent","sources","getSources","getTileCoordForCoordAndZ","col","row","getPixelData","altZ","getTileRangeForTileCoordAndZ","covered","forEach","clear","removeHelper","disposeInternal","deleteProgram","deleteBuffer"],"sources":["/Users/lydiaprice/quake-text/Frontend/node_modules/ol/renderer/webgl/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/TileLayer\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport TileTexture from '../../webgl/TileTexture.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {ELEMENT_ARRAY_BUFFER, STATIC_DRAW} from '../../webgl.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  reset as resetTransform,\n  rotate as rotateTransform,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {\n  boundingExtent,\n  containsCoordinate,\n  getIntersection,\n  isEmpty,\n} from '../../extent.js';\nimport {\n  create as createMat4,\n  fromTransform as mat4FromTransform,\n} from '../../vec/mat4.js';\nimport {\n  createOrUpdate as createTileCoord,\n  getKey as getTileCoordKey,\n} from '../../tilecoord.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {numberSafeCompareFunction} from '../../array.js';\nimport {toSize} from '../../size.js';\n\nexport const Uniforms = {\n  TILE_TEXTURE_ARRAY: 'u_tileTextures',\n  TILE_TRANSFORM: 'u_tileTransform',\n  TRANSITION_ALPHA: 'u_transitionAlpha',\n  DEPTH: 'u_depth',\n  TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',\n  TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',\n  TEXTURE_RESOLUTION: 'u_textureResolution', // map units per texture pixel\n  TEXTURE_ORIGIN_X: 'u_textureOriginX', // map x coordinate of left edge of texture\n  TEXTURE_ORIGIN_Y: 'u_textureOriginY', // map y coordinate of top edge of texture\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\n  RESOLUTION: 'u_resolution',\n  ZOOM: 'u_zoom',\n};\n\nexport const Attributes = {\n  TEXTURE_COORD: 'a_textureCoord',\n};\n\n/**\n * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n */\nconst attributeDescriptions = [\n  {\n    name: Attributes.TEXTURE_COORD,\n    size: 2,\n    type: AttributeType.FLOAT,\n  },\n];\n\n/**\n * @type {Object<string, boolean>}\n */\nconst empty = {};\n\n/**\n * Transform a zoom level into a depth value ranging from -1 to 1.\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\nfunction depthForZ(z) {\n  return 2 * (1 - 1 / (z + 1)) - 1;\n}\n\n/**\n * Add a tile texture to the lookup.\n * @param {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>} tileTexturesByZ Lookup of\n * tile textures by zoom level.\n * @param {import(\"../../webgl/TileTexture.js\").default} tileTexture A tile texture.\n * @param {number} z The zoom level.\n */\nfunction addTileTextureToLookup(tileTexturesByZ, tileTexture, z) {\n  if (!(z in tileTexturesByZ)) {\n    tileTexturesByZ[z] = [];\n  }\n  tileTexturesByZ[z].push(tileTexture);\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection)\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\nfunction getCacheKey(source, tileCoord) {\n  return `${source.getKey()},${getTileCoordKey(tileCoord)}`;\n}\n\n/**\n * @typedef {Object} Options\n * @property {string} vertexShader Vertex shader source.\n * @property {string} fragmentShader Fragment shader source.\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {Array<import(\"../../webgl/PaletteTexture.js\").default>} [paletteTextures] Palette textures.\n * @property {number} [cacheSize=512] The texture cache size.\n */\n\n/**\n * @typedef {import(\"../../layer/WebGLTile.js\").default} LayerType\n */\n\n/**\n * @classdesc\n * WebGL renderer for tile layers.\n * @extends {WebGLLayerRenderer<LayerType>}\n * @api\n */\nclass WebGLTileLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, {\n      uniforms: options.uniforms,\n    });\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * This transform converts texture coordinates to screen coordinates.\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.tileTransform_ = createTransform();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.tempMat4_ = createMat4();\n\n    /**\n     * @type {import(\"../../TileRange.js\").default}\n     * @private\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    /**\n     * @type {import(\"../../size.js\").Size}\n     * @private\n     */\n    this.tempSize_ = [0, 0];\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * Tiles are rendered as a quad with the following structure:\n     *\n     *  [P3]---------[P2]\n     *   |`           |\n     *   |  `     B   |\n     *   |    `       |\n     *   |      `     |\n     *   |   A    `   |\n     *   |          ` |\n     *  [P0]---------[P1]\n     *\n     * Triangle A: P0, P1, P3\n     * Triangle B: P1, P2, P3\n     *\n     * @private\n     */\n    this.indices_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\n    this.indices_.fromArray([0, 1, 3, 1, 2, 3]);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../webgl/TileTexture.js\").default>}\n     * @private\n     */\n    this.tileTextureCache_ = new LRUCache(cacheSize);\n\n    /**\n     * @type {Array<import(\"../../webgl/PaletteTexture.js\").default>}\n     * @private\n     */\n    this.paletteTextures_ = options.paletteTextures || [];\n\n    /**\n     * @private\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.projection_ = undefined;\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset({\n      uniforms: options.uniforms,\n    });\n    this.vertexShader_ = options.vertexShader;\n    this.fragmentShader_ = options.fragmentShader;\n    this.paletteTextures_ = options.paletteTextures || [];\n\n    if (this.helper) {\n      this.program_ = this.helper.getProgram(\n        this.fragmentShader_,\n        this.vertexShader_\n      );\n    }\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_\n    );\n\n    this.helper.flushBufferData(this.indices_);\n  }\n\n  /**\n   * @param {import(\"../../webgl/TileTexture\").TileType} tile Tile.\n   * @return {boolean} Tile is drawable.\n   * @private\n   */\n  isDrawableTile_(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    if (!this.projection_) {\n      this.projection_ = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.projection_) {\n      this.clearCache();\n      this.projection_ = frameState.viewState.projection;\n    }\n\n    const layer = this.getLayer();\n    const source = layer.getRenderSource();\n    if (!source) {\n      return false;\n    }\n\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n      return false;\n    }\n    return source.getState() === 'ready';\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {Object<number, Array<TileTexture>>} tileTexturesByZ The zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tileTexturesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileTextureCache = this.tileTextureCache_;\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0)\n        ),\n        tileSource.zDirection\n      )\n    );\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n          const cacheKey = getCacheKey(tileSource, tileCoord);\n\n          /** @type {TileTexture} */\n          let tileTexture;\n\n          /** @type {import(\"../../webgl/TileTexture\").TileType} */\n          let tile;\n\n          if (tileTextureCache.containsKey(cacheKey)) {\n            tileTexture = tileTextureCache.get(cacheKey);\n            tile = tileTexture.tile;\n          }\n          if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {\n            tile = tileSource.getTile(\n              z,\n              x,\n              y,\n              frameState.pixelRatio,\n              viewState.projection\n            );\n            if (!tileTexture) {\n              tileTexture = new TileTexture({\n                tile: tile,\n                grid: tileGrid,\n                helper: this.helper,\n                gutter: gutter,\n              });\n              tileTextureCache.set(cacheKey, tileTexture);\n            } else {\n              if (this.isDrawableTile_(tile)) {\n                tileTexture.setTile(tile);\n              } else {\n                const interimTile =\n                  /** @type {import(\"../../webgl/TileTexture\").TileType} */ (\n                    tile.getInterimTile()\n                  );\n                tileTexture.setTile(interimTile);\n              }\n            }\n          }\n\n          addTileTextureToLookup(tileTexturesByZ, tileTexture, z);\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    this.frameState_ = frameState;\n    this.renderComplete = true;\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const extent = getRenderExtent(frameState, frameState.extent);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection\n    );\n\n    /**\n     * @type {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>}\n     */\n    const tileTexturesByZ = {};\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(\n        frameState,\n        nextExtent,\n        targetZ,\n        tileTexturesByZ,\n        preload\n      );\n    }\n\n    this.enqueueTiles(frameState, extent, z, tileTexturesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          extent,\n          z - 1,\n          tileTexturesByZ,\n          preload - 1\n        );\n      }, 0);\n    }\n\n    /**\n     * A lookup of alpha values for tiles at the target rendering resolution\n     * for tiles that are in transition.  If a tile coord key is absent from\n     * this lookup, the tile should be rendered at alpha 1.\n     * @type {Object<string, number>}\n     */\n    const alphaLookup = {};\n\n    const uid = getUid(this);\n    const time = frameState.time;\n    let blend = false;\n\n    // look for cached tiles to use if a target tile is not ready\n    const tileTextures = tileTexturesByZ[z];\n    for (let i = 0, ii = tileTextures.length; i < ii; ++i) {\n      const tileTexture = tileTextures[i];\n      const tile = tileTexture.tile;\n      if (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileTexture.loaded) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n        blend = true;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        alphaLookup[tileCoordKey] = alpha;\n      }\n      this.renderComplete = false;\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tileTexturesByZ\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tileTexturesByZ\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState, !blend);\n\n    const zs = Object.keys(tileTexturesByZ)\n      .map(Number)\n      .sort(numberSafeCompareFunction);\n\n    const centerX = viewState.center[0];\n    const centerY = viewState.center[1];\n\n    for (let j = 0, jj = zs.length; j < jj; ++j) {\n      const tileZ = zs[j];\n      const tileResolution = tileGrid.getResolution(tileZ);\n      const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n      const tileOrigin = tileGrid.getOrigin(tileZ);\n\n      const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n      const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n      const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\n\n      const centerI =\n        (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n      const centerJ =\n        (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n\n      const tileScale = viewState.resolution / tileResolution;\n\n      const depth = depthForZ(tileZ);\n      const tileTextures = tileTexturesByZ[tileZ];\n      for (let i = 0, ii = tileTextures.length; i < ii; ++i) {\n        const tileTexture = tileTextures[i];\n        if (!tileTexture.loaded) {\n          continue;\n        }\n        const tile = tileTexture.tile;\n        const tileCoord = tile.tileCoord;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n\n        const tileCenterI = tileCoord[1];\n        const tileCenterJ = tileCoord[2];\n\n        resetTransform(this.tileTransform_);\n        scaleTransform(\n          this.tileTransform_,\n          2 / ((frameState.size[0] * tileScale) / tileWidthWithGutter),\n          -2 / ((frameState.size[1] * tileScale) / tileWidthWithGutter)\n        );\n        rotateTransform(this.tileTransform_, viewState.rotation);\n        scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\n        translateTransform(\n          this.tileTransform_,\n          (tileSize[0] * (tileCenterI - centerI) - gutter) /\n            tileWidthWithGutter,\n          (tileSize[1] * (tileCenterJ - centerJ) - gutter) /\n            tileHeightWithGutter\n        );\n\n        this.helper.setUniformMatrixValue(\n          Uniforms.TILE_TRANSFORM,\n          mat4FromTransform(this.tempMat4_, this.tileTransform_)\n        );\n\n        this.helper.bindBuffer(tileTexture.coords);\n        this.helper.bindBuffer(this.indices_);\n        this.helper.enableAttributes(attributeDescriptions);\n\n        let textureSlot = 0;\n        while (textureSlot < tileTexture.textures.length) {\n          const textureProperty = 'TEXTURE' + textureSlot;\n          const uniformName = `${Uniforms.TILE_TEXTURE_ARRAY}[${textureSlot}]`;\n          gl.activeTexture(gl[textureProperty]);\n          gl.bindTexture(gl.TEXTURE_2D, tileTexture.textures[textureSlot]);\n          gl.uniform1i(\n            this.helper.getUniformLocation(uniformName),\n            textureSlot\n          );\n          ++textureSlot;\n        }\n\n        for (\n          let paletteIndex = 0;\n          paletteIndex < this.paletteTextures_.length;\n          ++paletteIndex\n        ) {\n          const paletteTexture = this.paletteTextures_[paletteIndex];\n          gl.activeTexture(gl['TEXTURE' + textureSlot]);\n          const texture = paletteTexture.getTexture(gl);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          gl.uniform1i(\n            this.helper.getUniformLocation(paletteTexture.name),\n            textureSlot\n          );\n          ++textureSlot;\n        }\n\n        const alpha =\n          tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n\n        if (alpha < 1) {\n          frameState.animate = true;\n        }\n\n        this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\n        this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\n        this.helper.setUniformFloatValue(\n          Uniforms.TEXTURE_PIXEL_WIDTH,\n          tileWidthWithGutter\n        );\n        this.helper.setUniformFloatValue(\n          Uniforms.TEXTURE_PIXEL_HEIGHT,\n          tileHeightWithGutter\n        );\n        this.helper.setUniformFloatValue(\n          Uniforms.TEXTURE_RESOLUTION,\n          tileResolution\n        );\n        this.helper.setUniformFloatValue(\n          Uniforms.TEXTURE_ORIGIN_X,\n          tileOrigin[0] +\n            tileCenterI * tileSize[0] * tileResolution -\n            gutter * tileResolution\n        );\n        this.helper.setUniformFloatValue(\n          Uniforms.TEXTURE_ORIGIN_Y,\n          tileOrigin[1] -\n            tileCenterJ * tileSize[1] * tileResolution +\n            gutter * tileResolution\n        );\n        let gutterExtent = extent;\n        if (gutter > 0) {\n          gutterExtent = tileGrid.getTileCoordExtent(tileCoord);\n          getIntersection(gutterExtent, extent, gutterExtent);\n        }\n        this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);\n        this.helper.setUniformFloatValue(\n          Uniforms.RESOLUTION,\n          viewState.resolution\n        );\n        this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\n\n        this.helper.drawElements(0, this.indices_.getSize());\n      }\n    }\n\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent\n    );\n\n    const canvas = this.helper.getCanvas();\n\n    const tileTextureCache = this.tileTextureCache_;\n    while (tileTextureCache.canExpireCache()) {\n      const tileTexture = tileTextureCache.pop();\n      tileTexture.dispose();\n    }\n\n    // TODO: let the renderers manage their own cache instead of managing the source cache\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = function (map, frameState) {\n      tileSource.updateCacheSize(0.1, frameState.viewState.projection);\n      tileSource.expireCache(frameState.viewState.projection, empty);\n    };\n\n    frameState.postRenderFunctions.push(postRenderFunction);\n\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.\n   */\n  getData(pixel) {\n    const gl = this.helper.getGL();\n    if (!gl) {\n      return null;\n    }\n\n    const frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const viewState = frameState.viewState;\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (\n        !containsCoordinate(\n          fromUserExtent(layerExtent, viewState.projection),\n          coordinate\n        )\n      ) {\n        return null;\n      }\n    }\n\n    // determine last source suitable for rendering at coordinate\n    const sources = layer.getSources(\n      boundingExtent([coordinate]),\n      viewState.resolution\n    );\n    let i, source, tileGrid;\n    for (i = sources.length - 1; i >= 0; --i) {\n      source = sources[i];\n      if (source.getState() === 'ready') {\n        tileGrid = source.getTileGridForProjection(viewState.projection);\n        if (source.getWrapX()) {\n          break;\n        }\n        const gridExtent = tileGrid.getExtent();\n        if (!gridExtent || containsCoordinate(gridExtent, coordinate)) {\n          break;\n        }\n      }\n    }\n    if (i < 0) {\n      return null;\n    }\n\n    const tileTextureCache = this.tileTextureCache_;\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const cacheKey = getCacheKey(source, tileCoord);\n      if (!tileTextureCache.containsKey(cacheKey)) {\n        continue;\n      }\n      const tileTexture = tileTextureCache.get(cacheKey);\n      const tile = tileTexture.tile;\n      if (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY) {\n        return null;\n      }\n      if (!tileTexture.loaded) {\n        continue;\n      }\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col =\n        (coordinate[0] - tileOrigin[0]) / tileResolution -\n        tileCoord[1] * tileSize[0];\n\n      const row =\n        (tileOrigin[1] - coordinate[1]) / tileResolution -\n        tileCoord[2] * tileSize[1];\n\n      return tileTexture.getPixelData(col, row);\n    }\n    return null;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>} tileTexturesByZ Lookup of\n   * tile textures by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tileTexturesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileTextureCache = this.tileTextureCache_;\n    const source = this.getLayer().getRenderSource();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, [altZ, x, y]);\n        let loaded = false;\n        if (tileTextureCache.containsKey(cacheKey)) {\n          const tileTexture = tileTextureCache.get(cacheKey);\n          if (tileTexture.loaded) {\n            addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  clearCache() {\n    const tileTextureCache = this.tileTextureCache_;\n    tileTextureCache.forEach((tileTexture) => tileTexture.dispose());\n    tileTextureCache.clear();\n  }\n\n  removeHelper() {\n    if (this.helper) {\n      this.clearCache();\n    }\n\n    super.removeHelper();\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    const helper = this.helper;\n    if (helper) {\n      const gl = helper.getGL();\n      gl.deleteProgram(this.program_);\n      delete this.program_;\n\n      helper.deleteBuffer(this.indices_);\n    }\n\n    super.disposeInternal();\n\n    delete this.indices_;\n    delete this.tileTextureCache_;\n    delete this.frameState_;\n  }\n}\n\nexport default WebGLTileLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}