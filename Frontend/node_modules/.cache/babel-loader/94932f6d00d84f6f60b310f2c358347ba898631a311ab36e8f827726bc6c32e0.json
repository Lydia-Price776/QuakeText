{"ast":null,"code":"/**\n * @module ol/render/webgl/utils\n */\nimport earcut from 'earcut';\nimport { apply as applyTransform } from '../../transform.js';\nimport { clamp } from '../../math.js';\nconst tmpArray_ = [];\n\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\nconst bufferPositions_ = {\n  vertexPosition: 0,\n  indexPosition: 0\n};\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {\n  // This is for x, y and index\n  const baseVertexAttrsCount = 3;\n  const baseInstructionsCount = 2;\n  const stride = baseVertexAttrsCount + customAttributesCount;\n  const x = instructions[elementIndex + 0];\n  const y = instructions[elementIndex + 1];\n\n  // read custom numerical attributes on the feature\n  const customAttrs = tmpArray_;\n  customAttrs.length = customAttributesCount;\n  for (let i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  const baseIndex = vPos / stride;\n\n  // push vertices for each of the four quad corners (first standard then custom attributes)\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n  return bufferPositions_;\n}\n\n/**\n * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next\n * segment, in order to be able to offset the vertices correctly in the shader\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.\n * @param {number} segmentEndIndex Index of the segment start point from which render instructions will be read.\n * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)\n * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {Array<number>} customAttributes Array of custom attributes value\n * @param {import('../../transform.js').Transform} instructionsTransform Transform matrix used to project coordinates in instructions\n * @param {import('../../transform.js').Transform} invertInstructionsTransform Transform matrix used to project coordinates in instructions\n * @private\n */\nexport function writeLineSegmentToBuffers(instructions, segmentStartIndex, segmentEndIndex, beforeSegmentIndex, afterSegmentIndex, vertexArray, indexArray, customAttributes, instructionsTransform, invertInstructionsTransform) {\n  // compute the stride to determine how many vertices were already pushed\n  const baseVertexAttrsCount = 5; // base attributes: x0, y0, x1, y1, params (vertex number [0-3], join angle 1, join angle 2)\n  const stride = baseVertexAttrsCount + customAttributes.length;\n  const baseIndex = vertexArray.length / stride;\n\n  // The segment is composed of two positions called P0[x0, y0] and P1[x1, y1]\n  // Depending on whether there are points before and after the segment, its final shape\n  // will be different\n  const p0 = [instructions[segmentStartIndex + 0], instructions[segmentStartIndex + 1]];\n  const p1 = [instructions[segmentEndIndex], instructions[segmentEndIndex + 1]];\n\n  // to compute offsets from the line center we need to reproject\n  // coordinates back in world units and compute the length of the segment\n  const p0world = applyTransform(invertInstructionsTransform, [...p0]);\n  const p1world = applyTransform(invertInstructionsTransform, [...p1]);\n  function computeVertexParameters(vertexNumber, joinAngle1, joinAngle2) {\n    const shift = 10000;\n    const anglePrecision = 1500;\n    return Math.round(joinAngle1 * anglePrecision) + Math.round(joinAngle2 * anglePrecision) * shift + vertexNumber * shift * shift;\n  }\n\n  // compute the angle between p0pA and p0pB\n  // returns a value in [0, 2PI]\n  function angleBetween(p0, pA, pB) {\n    const lenA = Math.sqrt((pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1]));\n    const tangentA = [(pA[0] - p0[0]) / lenA, (pA[1] - p0[1]) / lenA];\n    const orthoA = [-tangentA[1], tangentA[0]];\n    const lenB = Math.sqrt((pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1]));\n    const tangentB = [(pB[0] - p0[0]) / lenB, (pB[1] - p0[1]) / lenB];\n\n    // this angle can be clockwise or anticlockwise; hence the computation afterwards\n    const angle = lenA === 0 || lenB === 0 ? 0 : Math.acos(clamp(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1));\n    const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;\n    return !isClockwise ? Math.PI * 2 - angle : angle;\n  }\n  const joinBefore = beforeSegmentIndex !== null;\n  const joinAfter = afterSegmentIndex !== null;\n  let angle0 = 0;\n  let angle1 = 0;\n\n  // add vertices and adapt offsets for P0 in case of join\n  if (joinBefore) {\n    // B for before\n    const pB = [instructions[beforeSegmentIndex], instructions[beforeSegmentIndex + 1]];\n    const pBworld = applyTransform(invertInstructionsTransform, [...pB]);\n    angle0 = angleBetween(p0world, p1world, pBworld);\n  }\n  // adapt offsets for P1 in case of join\n  if (joinAfter) {\n    // A for after\n    const pA = [instructions[afterSegmentIndex], instructions[afterSegmentIndex + 1]];\n    const pAworld = applyTransform(invertInstructionsTransform, [...pA]);\n    angle1 = angleBetween(p1world, p0world, pAworld);\n  }\n\n  // add main segment triangles\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], computeVertexParameters(0, angle0, angle1));\n  vertexArray.push(...customAttributes);\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], computeVertexParameters(1, angle0, angle1));\n  vertexArray.push(...customAttributes);\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], computeVertexParameters(2, angle0, angle1));\n  vertexArray.push(...customAttributes);\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], computeVertexParameters(3, angle0, angle1));\n  vertexArray.push(...customAttributes);\n  indexArray.push(baseIndex, baseIndex + 1, baseIndex + 2, baseIndex + 1, baseIndex + 3, baseIndex + 2);\n}\n\n/**\n * Pushes several triangles to form a polygon, including holes\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @return {number} Next polygon instructions index\n * @private\n */\nexport function writePolygonTrianglesToBuffers(instructions, polygonStartIndex, vertexArray, indexArray, customAttributesCount) {\n  const instructionsPerVertex = 2; // x, y\n  const attributesPerVertex = 2 + customAttributesCount;\n  let instructionsIndex = polygonStartIndex;\n  const customAttributes = instructions.slice(instructionsIndex, instructionsIndex + customAttributesCount);\n  instructionsIndex += customAttributesCount;\n  const ringsCount = instructions[instructionsIndex++];\n  let verticesCount = 0;\n  const holes = new Array(ringsCount - 1);\n  for (let i = 0; i < ringsCount; i++) {\n    verticesCount += instructions[instructionsIndex++];\n    if (i < ringsCount - 1) {\n      holes[i] = verticesCount;\n    }\n  }\n  const flatCoords = instructions.slice(instructionsIndex, instructionsIndex + verticesCount * instructionsPerVertex);\n\n  // pushing to vertices and indices!! this is where the magic happens\n  const result = earcut(flatCoords, holes, instructionsPerVertex);\n  for (let i = 0; i < result.length; i++) {\n    indexArray.push(result[i] + vertexArray.length / attributesPerVertex);\n  }\n  for (let i = 0; i < flatCoords.length; i += 2) {\n    vertexArray.push(flatCoords[i], flatCoords[i + 1], ...customAttributes);\n  }\n  return instructionsIndex + verticesCount * instructionsPerVertex;\n}\n\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n  const canvas = document.createElement('canvas');\n  const image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, array) {\n  array = array || [];\n  const radix = 256;\n  const divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = Math.floor(id / radix / radix) % radix / divide;\n  array[2] = Math.floor(id / radix) % radix / divide;\n  array[3] = id % radix / divide;\n  return array;\n}\n\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n  let id = 0;\n  const radix = 256;\n  const mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}","map":{"version":3,"names":["earcut","apply","applyTransform","clamp","tmpArray_","bufferPositions_","vertexPosition","indexPosition","writePointVertex","buffer","pos","x","y","index","writePointFeatureToBuffers","instructions","elementIndex","vertexBuffer","indexBuffer","customAttributesCount","bufferPositions","baseVertexAttrsCount","baseInstructionsCount","stride","customAttrs","length","i","vPos","iPos","baseIndex","set","writeLineSegmentToBuffers","segmentStartIndex","segmentEndIndex","beforeSegmentIndex","afterSegmentIndex","vertexArray","indexArray","customAttributes","instructionsTransform","invertInstructionsTransform","p0","p1","p0world","p1world","computeVertexParameters","vertexNumber","joinAngle1","joinAngle2","shift","anglePrecision","Math","round","angleBetween","pA","pB","lenA","sqrt","tangentA","orthoA","lenB","tangentB","angle","acos","isClockwise","PI","joinBefore","joinAfter","angle0","angle1","pBworld","pAworld","push","writePolygonTrianglesToBuffers","polygonStartIndex","instructionsPerVertex","attributesPerVertex","instructionsIndex","slice","ringsCount","verticesCount","holes","Array","flatCoords","result","getBlankImageData","canvas","document","createElement","image","getContext","createImageData","data","colorEncodeId","id","array","radix","divide","floor","colorDecodeId","color","mult"],"sources":["/Users/lydiaprice/quake-text/Frontend/node_modules/ol/render/webgl/utils.js"],"sourcesContent":["/**\n * @module ol/render/webgl/utils\n */\nimport earcut from 'earcut';\nimport {apply as applyTransform} from '../../transform.js';\nimport {clamp} from '../../math.js';\n\nconst tmpArray_ = [];\n\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\nconst bufferPositions_ = {vertexPosition: 0, indexPosition: 0};\n\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(\n  instructions,\n  elementIndex,\n  vertexBuffer,\n  indexBuffer,\n  customAttributesCount,\n  bufferPositions\n) {\n  // This is for x, y and index\n  const baseVertexAttrsCount = 3;\n  const baseInstructionsCount = 2;\n  const stride = baseVertexAttrsCount + customAttributesCount;\n\n  const x = instructions[elementIndex + 0];\n  const y = instructions[elementIndex + 1];\n\n  // read custom numerical attributes on the feature\n  const customAttrs = tmpArray_;\n  customAttrs.length = customAttributesCount;\n  for (let i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n\n  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  const baseIndex = vPos / stride;\n\n  // push vertices for each of the four quad corners (first standard then custom attributes)\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n\n  return bufferPositions_;\n}\n\n/**\n * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next\n * segment, in order to be able to offset the vertices correctly in the shader\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.\n * @param {number} segmentEndIndex Index of the segment start point from which render instructions will be read.\n * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)\n * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {Array<number>} customAttributes Array of custom attributes value\n * @param {import('../../transform.js').Transform} instructionsTransform Transform matrix used to project coordinates in instructions\n * @param {import('../../transform.js').Transform} invertInstructionsTransform Transform matrix used to project coordinates in instructions\n * @private\n */\nexport function writeLineSegmentToBuffers(\n  instructions,\n  segmentStartIndex,\n  segmentEndIndex,\n  beforeSegmentIndex,\n  afterSegmentIndex,\n  vertexArray,\n  indexArray,\n  customAttributes,\n  instructionsTransform,\n  invertInstructionsTransform\n) {\n  // compute the stride to determine how many vertices were already pushed\n  const baseVertexAttrsCount = 5; // base attributes: x0, y0, x1, y1, params (vertex number [0-3], join angle 1, join angle 2)\n  const stride = baseVertexAttrsCount + customAttributes.length;\n  const baseIndex = vertexArray.length / stride;\n\n  // The segment is composed of two positions called P0[x0, y0] and P1[x1, y1]\n  // Depending on whether there are points before and after the segment, its final shape\n  // will be different\n  const p0 = [\n    instructions[segmentStartIndex + 0],\n    instructions[segmentStartIndex + 1],\n  ];\n  const p1 = [instructions[segmentEndIndex], instructions[segmentEndIndex + 1]];\n\n  // to compute offsets from the line center we need to reproject\n  // coordinates back in world units and compute the length of the segment\n  const p0world = applyTransform(invertInstructionsTransform, [...p0]);\n  const p1world = applyTransform(invertInstructionsTransform, [...p1]);\n\n  function computeVertexParameters(vertexNumber, joinAngle1, joinAngle2) {\n    const shift = 10000;\n    const anglePrecision = 1500;\n    return (\n      Math.round(joinAngle1 * anglePrecision) +\n      Math.round(joinAngle2 * anglePrecision) * shift +\n      vertexNumber * shift * shift\n    );\n  }\n\n  // compute the angle between p0pA and p0pB\n  // returns a value in [0, 2PI]\n  function angleBetween(p0, pA, pB) {\n    const lenA = Math.sqrt(\n      (pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1])\n    );\n    const tangentA = [(pA[0] - p0[0]) / lenA, (pA[1] - p0[1]) / lenA];\n    const orthoA = [-tangentA[1], tangentA[0]];\n    const lenB = Math.sqrt(\n      (pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1])\n    );\n    const tangentB = [(pB[0] - p0[0]) / lenB, (pB[1] - p0[1]) / lenB];\n\n    // this angle can be clockwise or anticlockwise; hence the computation afterwards\n    const angle =\n      lenA === 0 || lenB === 0\n        ? 0\n        : Math.acos(\n            clamp(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1)\n          );\n    const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;\n    return !isClockwise ? Math.PI * 2 - angle : angle;\n  }\n\n  const joinBefore = beforeSegmentIndex !== null;\n  const joinAfter = afterSegmentIndex !== null;\n\n  let angle0 = 0;\n  let angle1 = 0;\n\n  // add vertices and adapt offsets for P0 in case of join\n  if (joinBefore) {\n    // B for before\n    const pB = [\n      instructions[beforeSegmentIndex],\n      instructions[beforeSegmentIndex + 1],\n    ];\n    const pBworld = applyTransform(invertInstructionsTransform, [...pB]);\n    angle0 = angleBetween(p0world, p1world, pBworld);\n  }\n  // adapt offsets for P1 in case of join\n  if (joinAfter) {\n    // A for after\n    const pA = [\n      instructions[afterSegmentIndex],\n      instructions[afterSegmentIndex + 1],\n    ];\n    const pAworld = applyTransform(invertInstructionsTransform, [...pA]);\n    angle1 = angleBetween(p1world, p0world, pAworld);\n  }\n\n  // add main segment triangles\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(0, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(1, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(2, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(3, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  indexArray.push(\n    baseIndex,\n    baseIndex + 1,\n    baseIndex + 2,\n    baseIndex + 1,\n    baseIndex + 3,\n    baseIndex + 2\n  );\n}\n\n/**\n * Pushes several triangles to form a polygon, including holes\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @return {number} Next polygon instructions index\n * @private\n */\nexport function writePolygonTrianglesToBuffers(\n  instructions,\n  polygonStartIndex,\n  vertexArray,\n  indexArray,\n  customAttributesCount\n) {\n  const instructionsPerVertex = 2; // x, y\n  const attributesPerVertex = 2 + customAttributesCount;\n  let instructionsIndex = polygonStartIndex;\n  const customAttributes = instructions.slice(\n    instructionsIndex,\n    instructionsIndex + customAttributesCount\n  );\n  instructionsIndex += customAttributesCount;\n  const ringsCount = instructions[instructionsIndex++];\n  let verticesCount = 0;\n  const holes = new Array(ringsCount - 1);\n  for (let i = 0; i < ringsCount; i++) {\n    verticesCount += instructions[instructionsIndex++];\n    if (i < ringsCount - 1) {\n      holes[i] = verticesCount;\n    }\n  }\n  const flatCoords = instructions.slice(\n    instructionsIndex,\n    instructionsIndex + verticesCount * instructionsPerVertex\n  );\n\n  // pushing to vertices and indices!! this is where the magic happens\n  const result = earcut(flatCoords, holes, instructionsPerVertex);\n  for (let i = 0; i < result.length; i++) {\n    indexArray.push(result[i] + vertexArray.length / attributesPerVertex);\n  }\n  for (let i = 0; i < flatCoords.length; i += 2) {\n    vertexArray.push(flatCoords[i], flatCoords[i + 1], ...customAttributes);\n  }\n\n  return instructionsIndex + verticesCount * instructionsPerVertex;\n}\n\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n  const canvas = document.createElement('canvas');\n  const image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, array) {\n  array = array || [];\n  const radix = 256;\n  const divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n  array[2] = (Math.floor(id / radix) % radix) / divide;\n  array[3] = (id % radix) / divide;\n  return array;\n}\n\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n  let id = 0;\n  const radix = 256;\n  const mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}