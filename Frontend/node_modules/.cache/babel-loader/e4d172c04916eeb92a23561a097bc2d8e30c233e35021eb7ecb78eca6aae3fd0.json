{"ast":null,"code":"/**\n * @module ol/format/KML\n */\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport Icon from '../style/Icon.js';\nimport ImageState from '../ImageState.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport XMLFeature from './XMLFeature.js';\nimport { OBJECT_PROPERTY_NODE_FACTORY, XML_SCHEMA_INSTANCE_URI, createElementNS, getAllTextContent, isDocument, makeArrayExtender, makeArrayPusher, makeChildAppender, makeObjectPropertySetter, makeReplacer, makeSequence, makeSimpleNodeFactory, makeStructureNS, parse, parseNode, pushParseAndPop, pushSerializeAndPop } from '../xml.js';\nimport { asArray } from '../color.js';\nimport { assert } from '../asserts.js';\nimport { extend } from '../array.js';\nimport { get as getProjection } from '../proj.js';\nimport { readBoolean, readDecimal, readString, writeBooleanTextNode, writeCDATASection, writeDecimalTextNode, writeStringTextNode } from './xsd.js';\nimport { toRadians } from '../math.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n\n/**\n * @typedef {Object} Vec2\n * @property {number} x X coordinate.\n * @property {import(\"../style/Icon.js\").IconAnchorUnits} xunits Units of x.\n * @property {number} y Y coordinate.\n * @property {import(\"../style/Icon.js\").IconAnchorUnits} yunits Units of Y.\n * @property {import(\"../style/Icon.js\").IconOrigin} [origin] Origin.\n */\n\n/**\n * @typedef {Object} GxTrackObject\n * @property {Array<Array<number>>} coordinates Coordinates.\n * @property {Array<number>} whens Whens.\n */\n\n/**\n * @const\n * @type {Array<string>}\n */\nconst GX_NAMESPACE_URIS = ['http://www.google.com/kml/ext/2.2'];\n\n/**\n * @const\n * @type {Array<null|string>}\n */\nconst NAMESPACE_URIS = [null, 'http://earth.google.com/kml/2.0', 'http://earth.google.com/kml/2.1', 'http://earth.google.com/kml/2.2', 'http://www.opengis.net/kml/2.2'];\n\n/**\n * @const\n * @type {string}\n */\nconst SCHEMA_LOCATION = 'http://www.opengis.net/kml/2.2 ' + 'https://developers.google.com/kml/schema/kml22gx.xsd';\n\n/**\n * @type {Object<string, import(\"../style/Icon.js\").IconAnchorUnits>}\n */\nconst ICON_ANCHOR_UNITS_MAP = {\n  'fraction': 'fraction',\n  'pixels': 'pixels',\n  'insetPixels': 'pixels'\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PLACEMARK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ExtendedData': extendedDataParser,\n  'Region': regionParser,\n  'MultiGeometry': makeObjectPropertySetter(readMultiGeometry, 'geometry'),\n  'LineString': makeObjectPropertySetter(readLineString, 'geometry'),\n  'LinearRing': makeObjectPropertySetter(readLinearRing, 'geometry'),\n  'Point': makeObjectPropertySetter(readPoint, 'geometry'),\n  'Polygon': makeObjectPropertySetter(readPolygon, 'geometry'),\n  'Style': makeObjectPropertySetter(readStyle),\n  'StyleMap': placemarkStyleMapParser,\n  'address': makeObjectPropertySetter(readString),\n  'description': makeObjectPropertySetter(readString),\n  'name': makeObjectPropertySetter(readString),\n  'open': makeObjectPropertySetter(readBoolean),\n  'phoneNumber': makeObjectPropertySetter(readString),\n  'styleUrl': makeObjectPropertySetter(readStyleURL),\n  'visibility': makeObjectPropertySetter(readBoolean)\n}, makeStructureNS(GX_NAMESPACE_URIS, {\n  'MultiTrack': makeObjectPropertySetter(readGxMultiTrack, 'geometry'),\n  'Track': makeObjectPropertySetter(readGxTrack, 'geometry')\n}));\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst NETWORK_LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ExtendedData': extendedDataParser,\n  'Region': regionParser,\n  'Link': linkParser,\n  'address': makeObjectPropertySetter(readString),\n  'description': makeObjectPropertySetter(readString),\n  'name': makeObjectPropertySetter(readString),\n  'open': makeObjectPropertySetter(readBoolean),\n  'phoneNumber': makeObjectPropertySetter(readString),\n  'visibility': makeObjectPropertySetter(readBoolean)\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'href': makeObjectPropertySetter(readURI)\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst REGION_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LatLonAltBox': latLonAltBoxParser,\n  'Lod': lodParser\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst KML_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['Document', 'Placemark']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst KML_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Document': makeChildAppender(writeDocument),\n  'Placemark': makeChildAppender(writePlacemark)\n});\n\n/**\n * @type {import(\"../color.js\").Color}\n */\nlet DEFAULT_COLOR;\n\n/**\n * @type {Fill|null}\n */\nlet DEFAULT_FILL_STYLE = null;\n\n/**\n * Get the default fill style (or null if not yet set).\n * @return {Fill|null} The default fill style.\n */\nexport function getDefaultFillStyle() {\n  return DEFAULT_FILL_STYLE;\n}\n\n/**\n * @type {import(\"../size.js\").Size}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR;\n\n/**\n * @type {import(\"../style/Icon.js\").IconAnchorUnits}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n\n/**\n * @type {import(\"../style/Icon.js\").IconAnchorUnits}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n\n/**\n * @type {import(\"../size.js\").Size}\n */\nlet DEFAULT_IMAGE_STYLE_SIZE;\n\n/**\n * @type {string}\n */\nlet DEFAULT_IMAGE_STYLE_SRC;\n\n/**\n * @type {import(\"../style/Image.js\").default|null}\n */\nlet DEFAULT_IMAGE_STYLE = null;\n\n/**\n * Get the default image style (or null if not yet set).\n * @return {import(\"../style/Image.js\").default|null} The default image style.\n */\nexport function getDefaultImageStyle() {\n  return DEFAULT_IMAGE_STYLE;\n}\n\n/**\n * @type {string}\n */\nlet DEFAULT_NO_IMAGE_STYLE;\n\n/**\n * @type {Stroke|null}\n */\nlet DEFAULT_STROKE_STYLE = null;\n\n/**\n * Get the default stroke style (or null if not yet set).\n * @return {Stroke|null} The default stroke style.\n */\nexport function getDefaultStrokeStyle() {\n  return DEFAULT_STROKE_STYLE;\n}\n\n/**\n * @type {Stroke}\n */\nlet DEFAULT_TEXT_STROKE_STYLE;\n\n/**\n * @type {Text|null}\n */\nlet DEFAULT_TEXT_STYLE = null;\n\n/**\n * Get the default text style (or null if not yet set).\n * @return {Text|null} The default text style.\n */\nexport function getDefaultTextStyle() {\n  return DEFAULT_TEXT_STYLE;\n}\n\n/**\n * @type {Style|null}\n */\nlet DEFAULT_STYLE = null;\n\n/**\n * Get the default style (or null if not yet set).\n * @return {Style|null} The default style.\n */\nexport function getDefaultStyle() {\n  return DEFAULT_STYLE;\n}\n\n/**\n * @type {Array<Style>|null}\n */\nlet DEFAULT_STYLE_ARRAY = null;\n\n/**\n * Get the default style array (or null if not yet set).\n * @return {Array<Style>|null} The default style.\n */\nexport function getDefaultStyleArray() {\n  return DEFAULT_STYLE_ARRAY;\n}\n\n/**\n * Function that returns the scale needed to normalize an icon image to 32 pixels.\n * @param {import(\"../size.js\").Size} size Image size.\n * @return {number} Scale.\n */\nfunction scaleForSize(size) {\n  return 32 / Math.min(size[0], size[1]);\n}\nfunction createStyleDefaults() {\n  DEFAULT_COLOR = [255, 255, 255, 1];\n  DEFAULT_FILL_STYLE = new Fill({\n    color: DEFAULT_COLOR\n  });\n  DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];\n  DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = 'pixels';\n  DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = 'pixels';\n  DEFAULT_IMAGE_STYLE_SIZE = [64, 64];\n  DEFAULT_IMAGE_STYLE_SRC = 'https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png';\n  DEFAULT_IMAGE_STYLE = new Icon({\n    anchor: DEFAULT_IMAGE_STYLE_ANCHOR,\n    anchorOrigin: 'bottom-left',\n    anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,\n    anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,\n    crossOrigin: 'anonymous',\n    rotation: 0,\n    scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),\n    size: DEFAULT_IMAGE_STYLE_SIZE,\n    src: DEFAULT_IMAGE_STYLE_SRC\n  });\n  DEFAULT_NO_IMAGE_STYLE = 'NO_IMAGE';\n  DEFAULT_STROKE_STYLE = new Stroke({\n    color: DEFAULT_COLOR,\n    width: 1\n  });\n  DEFAULT_TEXT_STROKE_STYLE = new Stroke({\n    color: [51, 51, 51, 1],\n    width: 2\n  });\n  DEFAULT_TEXT_STYLE = new Text({\n    font: 'bold 16px Helvetica',\n    fill: DEFAULT_FILL_STYLE,\n    stroke: DEFAULT_TEXT_STROKE_STYLE,\n    scale: 0.8\n  });\n  DEFAULT_STYLE = new Style({\n    fill: DEFAULT_FILL_STYLE,\n    image: DEFAULT_IMAGE_STYLE,\n    text: DEFAULT_TEXT_STYLE,\n    stroke: DEFAULT_STROKE_STYLE,\n    zIndex: 0\n  });\n  DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];\n}\n\n/**\n * @type {HTMLTextAreaElement}\n */\nlet TEXTAREA;\n\n/**\n * A function that takes a url `{string}` and returns a url `{string}`.\n * Might be used to change an icon path or to substitute a\n * data url obtained from a KMZ array buffer.\n *\n * @typedef {function(string):string} IconUrlFunction\n * @api\n */\n\n/**\n * Function that returns a url unchanged.\n * @param {string} href Input url.\n * @return {string} Output url.\n */\nfunction defaultIconUrlFunction(href) {\n  return href;\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [extractStyles=true] Extract styles from the KML.\n * @property {boolean} [showPointNames=true] Show names as labels for placemarks which contain points.\n * @property {Array<Style>} [defaultStyle] Default style. The\n * default default style is the same as Google Earth.\n * @property {boolean} [writeStyles=true] Write styles into KML.\n * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images. Note that you must provide a\n * `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * @property {IconUrlFunction} [iconUrlFunction] Function that takes a url string and returns a url string.\n * Might be used to change an icon path or to substitute a data url obtained from a KMZ array buffer.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the KML format.\n *\n * {@link module:ol/format/KML~KML#readFeature} will read the first feature from\n * a KML source.\n *\n * MultiGeometries are converted into GeometryCollections if they are a mix of\n * geometry types, and into MultiPoint/MultiLineString/MultiPolygon if they are\n * all of the same type.\n *\n * @api\n */\nclass KML extends XMLFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n    options = options ? options : {};\n    if (!DEFAULT_STYLE_ARRAY) {\n      createStyleDefaults();\n    }\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {Array<Style>}\n     */\n    this.defaultStyle_ = options.defaultStyle ? options.defaultStyle : DEFAULT_STYLE_ARRAY;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.extractStyles_ = options.extractStyles !== undefined ? options.extractStyles : true;\n\n    /**\n     * @type {boolean}\n     */\n    this.writeStyles_ = options.writeStyles !== undefined ? options.writeStyles : true;\n\n    /**\n     * @private\n     * @type {!Object<string, (Array<Style>|string)>}\n     */\n    this.sharedStyles_ = {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.showPointNames_ = options.showPointNames !== undefined ? options.showPointNames : true;\n\n    /**\n     * @type {null|string}\n     */\n    this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';\n\n    /**\n     * @type {IconUrlFunction}\n     */\n    this.iconUrlFunction_ = options.iconUrlFunction ? options.iconUrlFunction : defaultIconUrlFunction;\n    this.supportedMediaTypes = ['application/vnd.google-earth.kml+xml'];\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<Feature>|undefined} Features.\n   */\n  readDocumentOrFolder_(node, objectStack) {\n    // FIXME use scope somehow\n    const parsersNS = makeStructureNS(NAMESPACE_URIS, {\n      'Document': makeArrayExtender(this.readDocumentOrFolder_, this),\n      'Folder': makeArrayExtender(this.readDocumentOrFolder_, this),\n      'Placemark': makeArrayPusher(this.readPlacemark_, this),\n      'Style': this.readSharedStyle_.bind(this),\n      'StyleMap': this.readSharedStyleMap_.bind(this)\n    });\n    /** @type {Array<Feature>} */\n    // @ts-ignore\n    const features = pushParseAndPop([], parsersNS, node, objectStack, this);\n    if (features) {\n      return features;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Feature|undefined} Feature.\n   */\n  readPlacemark_(node, objectStack) {\n    const object = pushParseAndPop({\n      'geometry': null\n    }, PLACEMARK_PARSERS, node, objectStack, this);\n    if (!object) {\n      return undefined;\n    }\n    const feature = new Feature();\n    const id = node.getAttribute('id');\n    if (id !== null) {\n      feature.setId(id);\n    }\n    const options = /** @type {import(\"./Feature.js\").ReadOptions} */\n    objectStack[0];\n    const geometry = object['geometry'];\n    if (geometry) {\n      transformGeometryWithOptions(geometry, false, options);\n    }\n    feature.setGeometry(geometry);\n    delete object['geometry'];\n    if (this.extractStyles_) {\n      const style = object['Style'];\n      const styleUrl = object['styleUrl'];\n      const styleFunction = createFeatureStyleFunction(style, styleUrl, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);\n      feature.setStyle(styleFunction);\n    }\n    delete object['Style'];\n    // we do not remove the styleUrl property from the object, so it\n    // gets stored on feature when setProperties is called\n\n    feature.setProperties(object, true);\n    return feature;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  readSharedStyle_(node, objectStack) {\n    const id = node.getAttribute('id');\n    if (id !== null) {\n      const style = readStyle.call(this, node, objectStack);\n      if (style) {\n        let styleUri;\n        let baseURI = node.baseURI;\n        if (!baseURI || baseURI == 'about:blank') {\n          baseURI = window.location.href;\n        }\n        if (baseURI) {\n          const url = new URL('#' + id, baseURI);\n          styleUri = url.href;\n        } else {\n          styleUri = '#' + id;\n        }\n        this.sharedStyles_[styleUri] = style;\n      }\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  readSharedStyleMap_(node, objectStack) {\n    const id = node.getAttribute('id');\n    if (id === null) {\n      return;\n    }\n    const styleMapValue = readStyleMapValue.call(this, node, objectStack);\n    if (!styleMapValue) {\n      return;\n    }\n    let styleUri;\n    let baseURI = node.baseURI;\n    if (!baseURI || baseURI == 'about:blank') {\n      baseURI = window.location.href;\n    }\n    if (baseURI) {\n      const url = new URL('#' + id, baseURI);\n      styleUri = url.href;\n    } else {\n      styleUri = '#' + id;\n    }\n    this.sharedStyles_[styleUri] = styleMapValue;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, options) {\n    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {\n      return null;\n    }\n    const feature = this.readPlacemark_(node, [this.getReadOptions(node, options)]);\n    if (feature) {\n      return feature;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {\n      return [];\n    }\n    let features;\n    const localName = node.localName;\n    if (localName == 'Document' || localName == 'Folder') {\n      features = this.readDocumentOrFolder_(node, [this.getReadOptions(node, options)]);\n      if (features) {\n        return features;\n      } else {\n        return [];\n      }\n    } else if (localName == 'Placemark') {\n      const feature = this.readPlacemark_(node, [this.getReadOptions(node, options)]);\n      if (feature) {\n        return [feature];\n      } else {\n        return [];\n      }\n    } else if (localName == 'kml') {\n      features = [];\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        const fs = this.readFeaturesFromNode(n, options);\n        if (fs) {\n          extend(features, fs);\n        }\n      }\n      return features;\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Read the name of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {string|undefined} Name.\n   * @api\n   */\n  readName(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readNameFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readNameFromDocument( /** @type {Document} */source);\n    } else {\n      return this.readNameFromNode( /** @type {Element} */source);\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {string|undefined} Name.\n   */\n  readNameFromDocument(doc) {\n    for (let n = /** @type {Node} */doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        const name = this.readNameFromNode( /** @type {Element} */n);\n        if (name) {\n          return name;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {string|undefined} Name.\n   */\n  readNameFromNode(node) {\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'name') {\n        return readString(n);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && (localName == 'Document' || localName == 'Folder' || localName == 'Placemark' || localName == 'kml')) {\n        const name = this.readNameFromNode(n);\n        if (name) {\n          return name;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Read the network links of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {Array<Object>} Network links.\n   * @api\n   */\n  readNetworkLinks(source) {\n    const networkLinks = [];\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      extend(networkLinks, this.readNetworkLinksFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend(networkLinks, this.readNetworkLinksFromDocument( /** @type {Document} */source));\n    } else {\n      extend(networkLinks, this.readNetworkLinksFromNode( /** @type {Element} */source));\n    }\n    return networkLinks;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Array<Object>} Network links.\n   */\n  readNetworkLinksFromDocument(doc) {\n    const networkLinks = [];\n    for (let n = /** @type {Node} */doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(networkLinks, this.readNetworkLinksFromNode( /** @type {Element} */n));\n      }\n    }\n    return networkLinks;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Array<Object>} Network links.\n   */\n  readNetworkLinksFromNode(node) {\n    const networkLinks = [];\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'NetworkLink') {\n        const obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n, []);\n        networkLinks.push(obj);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && (localName == 'Document' || localName == 'Folder' || localName == 'kml')) {\n        extend(networkLinks, this.readNetworkLinksFromNode(n));\n      }\n    }\n    return networkLinks;\n  }\n\n  /**\n   * Read the regions of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {Array<Object>} Regions.\n   * @api\n   */\n  readRegion(source) {\n    const regions = [];\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      extend(regions, this.readRegionFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend(regions, this.readRegionFromDocument( /** @type {Document} */source));\n    } else {\n      extend(regions, this.readRegionFromNode( /** @type {Element} */source));\n    }\n    return regions;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Array<Object>} Region.\n   */\n  readRegionFromDocument(doc) {\n    const regions = [];\n    for (let n = /** @type {Node} */doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(regions, this.readRegionFromNode( /** @type {Element} */n));\n      }\n    }\n    return regions;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Array<Object>} Region.\n   * @api\n   */\n  readRegionFromNode(node) {\n    const regions = [];\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'Region') {\n        const obj = pushParseAndPop({}, REGION_PARSERS, n, []);\n        regions.push(obj);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && (localName == 'Document' || localName == 'Folder' || localName == 'kml')) {\n        extend(regions, this.readRegionFromNode(n));\n      }\n    }\n    return regions;\n  }\n\n  /**\n   * Encode an array of features in the KML format as an XML node. GeometryCollections,\n   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.\n   *\n   * @param {Array<Feature>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   * @api\n   */\n  writeFeaturesNode(features, options) {\n    options = this.adaptOptions(options);\n    const kml = createElementNS(NAMESPACE_URIS[4], 'kml');\n    const xmlnsUri = 'http://www.w3.org/2000/xmlns/';\n    kml.setAttributeNS(xmlnsUri, 'xmlns:gx', GX_NAMESPACE_URIS[0]);\n    kml.setAttributeNS(xmlnsUri, 'xmlns:xsi', XML_SCHEMA_INSTANCE_URI);\n    kml.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', SCHEMA_LOCATION);\n    const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n      node: kml\n    };\n    /** @type {!Object<string, (Array<Feature>|Feature|undefined)>} */\n    const properties = {};\n    if (features.length > 1) {\n      properties['Document'] = features;\n    } else if (features.length == 1) {\n      properties['Placemark'] = features[0];\n    }\n    const orderedKeys = KML_SEQUENCE[kml.namespaceURI];\n    const values = makeSequence(properties, orderedKeys);\n    pushSerializeAndPop(context, KML_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, [options], orderedKeys, this);\n    return kml;\n  }\n}\n\n/**\n * @param {Style|undefined} foundStyle Style.\n * @param {string} name Name.\n * @return {Style} style Style.\n */\nfunction createNameStyleFunction(foundStyle, name) {\n  const textOffset = [0, 0];\n  /** @type {CanvasTextAlign} */\n  let textAlign = 'start';\n  const imageStyle = foundStyle.getImage();\n  if (imageStyle) {\n    const imageSize = imageStyle.getSize();\n    if (imageSize && imageSize.length == 2) {\n      const imageScale = imageStyle.getScaleArray();\n      const anchor = imageStyle.getAnchor();\n      // Offset the label to be centered to the right of the icon,\n      // if there is one.\n      textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);\n      textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);\n      textAlign = 'left';\n    }\n  }\n  let textStyle = foundStyle.getText();\n  if (textStyle) {\n    // clone the text style, customizing it with name, alignments and offset.\n    // Note that kml does not support many text options that OpenLayers does (rotation, textBaseline).\n    textStyle = textStyle.clone();\n    textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());\n    textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());\n    textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());\n    textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);\n  } else {\n    textStyle = DEFAULT_TEXT_STYLE.clone();\n  }\n  textStyle.setText(name);\n  textStyle.setOffsetX(textOffset[0]);\n  textStyle.setOffsetY(textOffset[1]);\n  textStyle.setTextAlign(textAlign);\n  const nameStyle = new Style({\n    image: imageStyle,\n    text: textStyle\n  });\n  return nameStyle;\n}\n\n/**\n * @param {Array<Style>|undefined} style Style.\n * @param {string} styleUrl Style URL.\n * @param {Array<Style>} defaultStyle Default style.\n * @param {!Object<string, (Array<Style>|string)>} sharedStyles Shared styles.\n * @param {boolean|undefined} showPointNames true to show names for point placemarks.\n * @return {import(\"../style/Style.js\").StyleFunction} Feature style function.\n */\nfunction createFeatureStyleFunction(style, styleUrl, defaultStyle, sharedStyles, showPointNames) {\n  return (\n    /**\n     * @param {Feature} feature feature.\n     * @param {number} resolution Resolution.\n     * @return {Array<Style>|Style} Style.\n     */\n    function (feature, resolution) {\n      let drawName = showPointNames;\n      let name = '';\n      let multiGeometryPoints = [];\n      if (drawName) {\n        const geometry = feature.getGeometry();\n        if (geometry) {\n          if (geometry instanceof GeometryCollection) {\n            multiGeometryPoints = geometry.getGeometriesArrayRecursive().filter(function (geometry) {\n              const type = geometry.getType();\n              return type === 'Point' || type === 'MultiPoint';\n            });\n            drawName = multiGeometryPoints.length > 0;\n          } else {\n            const type = geometry.getType();\n            drawName = type === 'Point' || type === 'MultiPoint';\n          }\n        }\n      }\n      if (drawName) {\n        name = /** @type {string} */feature.get('name');\n        drawName = drawName && !!name;\n        // convert any html character codes\n        if (drawName && /&[^&]+;/.test(name)) {\n          if (!TEXTAREA) {\n            TEXTAREA = document.createElement('textarea');\n          }\n          TEXTAREA.innerHTML = name;\n          name = TEXTAREA.value;\n        }\n      }\n      let featureStyle = defaultStyle;\n      if (style) {\n        featureStyle = style;\n      } else if (styleUrl) {\n        featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);\n      }\n      if (drawName) {\n        const nameStyle = createNameStyleFunction(featureStyle[0], name);\n        if (multiGeometryPoints.length > 0) {\n          // in multigeometries restrict the name style to points and create a\n          // style without image or text for geometries requiring fill or stroke\n          // including any polygon specific style if there is one\n          nameStyle.setGeometry(new GeometryCollection(multiGeometryPoints));\n          const baseStyle = new Style({\n            geometry: featureStyle[0].getGeometry(),\n            image: null,\n            fill: featureStyle[0].getFill(),\n            stroke: featureStyle[0].getStroke(),\n            text: null\n          });\n          return [nameStyle, baseStyle].concat(featureStyle.slice(1));\n        }\n        return nameStyle;\n      }\n      return featureStyle;\n    }\n  );\n}\n\n/**\n * @param {Array<Style>|string|undefined} styleValue Style value.\n * @param {Array<Style>} defaultStyle Default style.\n * @param {!Object<string, (Array<Style>|string)>} sharedStyles\n * Shared styles.\n * @return {Array<Style>} Style.\n */\nfunction findStyle(styleValue, defaultStyle, sharedStyles) {\n  if (Array.isArray(styleValue)) {\n    return styleValue;\n  } else if (typeof styleValue === 'string') {\n    return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);\n  } else {\n    return defaultStyle;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {import(\"../color.js\").Color|undefined} Color.\n */\nfunction readColor(node) {\n  const s = getAllTextContent(node, false);\n  // The KML specification states that colors should not include a leading `#`\n  // but we tolerate them.\n  const m = /^\\s*#?\\s*([0-9A-Fa-f]{8})\\s*$/.exec(s);\n  if (m) {\n    const hexColor = m[1];\n    return [parseInt(hexColor.substr(6, 2), 16), parseInt(hexColor.substr(4, 2), 16), parseInt(hexColor.substr(2, 2), 16), parseInt(hexColor.substr(0, 2), 16) / 255];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {Array<number>|undefined} Flat coordinates.\n */\nexport function readFlatCoordinates(node) {\n  let s = getAllTextContent(node, false);\n  const flatCoordinates = [];\n  // The KML specification states that coordinate tuples should not include\n  // spaces, but we tolerate them.\n  s = s.replace(/\\s*,\\s*/g, ',');\n  const re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?),([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|,|$)(?:([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|$))?\\s*/i;\n  let m;\n  while (m = re.exec(s)) {\n    const x = parseFloat(m[1]);\n    const y = parseFloat(m[2]);\n    const z = m[3] ? parseFloat(m[3]) : 0;\n    flatCoordinates.push(x, y, z);\n    s = s.substr(m[0].length);\n  }\n  if (s !== '') {\n    return undefined;\n  }\n  return flatCoordinates;\n}\n\n/**\n * @param {Node} node Node.\n * @return {string} URI.\n */\nfunction readURI(node) {\n  const s = getAllTextContent(node, false).trim();\n  let baseURI = node.baseURI;\n  if (!baseURI || baseURI == 'about:blank') {\n    baseURI = window.location.href;\n  }\n  if (baseURI) {\n    const url = new URL(s, baseURI);\n    return url.href;\n  } else {\n    return s;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {string} URI.\n */\nfunction readStyleURL(node) {\n  // KML files in the wild occasionally forget the leading\n  // `#` on styleUrlsdefined in the same document.\n  const s = getAllTextContent(node, false).trim().replace(/^(?!.*#)/, '#');\n  let baseURI = node.baseURI;\n  if (!baseURI || baseURI == 'about:blank') {\n    baseURI = window.location.href;\n  }\n  if (baseURI) {\n    const url = new URL(s, baseURI);\n    return url.href;\n  } else {\n    return s;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @return {Vec2} Vec2.\n */\nfunction readVec2(node) {\n  const xunits = node.getAttribute('xunits');\n  const yunits = node.getAttribute('yunits');\n  /** @type {import('../style/Icon.js').IconOrigin} */\n  let origin;\n  if (xunits !== 'insetPixels') {\n    if (yunits !== 'insetPixels') {\n      origin = 'bottom-left';\n    } else {\n      origin = 'top-left';\n    }\n  } else {\n    if (yunits !== 'insetPixels') {\n      origin = 'bottom-right';\n    } else {\n      origin = 'top-right';\n    }\n  }\n  return {\n    x: parseFloat(node.getAttribute('x')),\n    xunits: ICON_ANCHOR_UNITS_MAP[xunits],\n    y: parseFloat(node.getAttribute('y')),\n    yunits: ICON_ANCHOR_UNITS_MAP[yunits],\n    origin: origin\n  };\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Scale.\n */\nfunction readScale(node) {\n  return readDecimal(node);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst STYLE_MAP_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Pair': pairDataParser\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<Style>|string|undefined} StyleMap.\n */\nfunction readStyleMapValue(node, objectStack) {\n  return pushParseAndPop(undefined, STYLE_MAP_PARSERS, node, objectStack, this);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ICON_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Icon': makeObjectPropertySetter(readIcon),\n  'color': makeObjectPropertySetter(readColor),\n  'heading': makeObjectPropertySetter(readDecimal),\n  'hotSpot': makeObjectPropertySetter(readVec2),\n  'scale': makeObjectPropertySetter(readScale)\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction iconStyleParser(node, objectStack) {\n  // FIXME refreshMode\n  // FIXME refreshInterval\n  // FIXME viewRefreshTime\n  // FIXME viewBoundScale\n  // FIXME viewFormat\n  // FIXME httpQuery\n  const object = pushParseAndPop({}, ICON_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = /** @type {Object} */\n  objectStack[objectStack.length - 1];\n  const IconObject = 'Icon' in object ? object['Icon'] : {};\n  const drawIcon = !('Icon' in object) || Object.keys(IconObject).length > 0;\n  let src;\n  const href = /** @type {string|undefined} */IconObject['href'];\n  if (href) {\n    src = href;\n  } else if (drawIcon) {\n    src = DEFAULT_IMAGE_STYLE_SRC;\n  }\n  let anchor, anchorXUnits, anchorYUnits;\n  /** @type {import('../style/Icon.js').IconOrigin|undefined} */\n  let anchorOrigin = 'bottom-left';\n  const hotSpot = /** @type {Vec2|undefined} */object['hotSpot'];\n  if (hotSpot) {\n    anchor = [hotSpot.x, hotSpot.y];\n    anchorXUnits = hotSpot.xunits;\n    anchorYUnits = hotSpot.yunits;\n    anchorOrigin = hotSpot.origin;\n  } else if (/^https?:\\/\\/maps\\.(?:google|gstatic)\\.com\\//.test(src)) {\n    // Google hotspots from https://kml4earth.appspot.com/icons.html#notes\n    if (src.includes('pushpin')) {\n      anchor = DEFAULT_IMAGE_STYLE_ANCHOR;\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    } else if (src.includes('arrow-reverse')) {\n      anchor = [54, 42];\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    } else if (src.includes('paddle')) {\n      anchor = [32, 1];\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    }\n  }\n  let offset;\n  const x = /** @type {number|undefined} */IconObject['x'];\n  const y = /** @type {number|undefined} */IconObject['y'];\n  if (x !== undefined && y !== undefined) {\n    offset = [x, y];\n  }\n  let size;\n  const w = /** @type {number|undefined} */IconObject['w'];\n  const h = /** @type {number|undefined} */IconObject['h'];\n  if (w !== undefined && h !== undefined) {\n    size = [w, h];\n  }\n  let rotation;\n  const heading = /** @type {number} */object['heading'];\n  if (heading !== undefined) {\n    rotation = toRadians(heading);\n  }\n  const scale = /** @type {number|undefined} */object['scale'];\n  const color = /** @type {Array<number>|undefined} */object['color'];\n  if (drawIcon) {\n    if (src == DEFAULT_IMAGE_STYLE_SRC) {\n      size = DEFAULT_IMAGE_STYLE_SIZE;\n    }\n    const imageStyle = new Icon({\n      anchor: anchor,\n      anchorOrigin: anchorOrigin,\n      anchorXUnits: anchorXUnits,\n      anchorYUnits: anchorYUnits,\n      crossOrigin: this.crossOrigin_,\n      offset: offset,\n      offsetOrigin: 'bottom-left',\n      rotation: rotation,\n      scale: scale,\n      size: size,\n      src: this.iconUrlFunction_(src),\n      color: color\n    });\n    const imageScale = imageStyle.getScaleArray()[0];\n    const imageSize = imageStyle.getSize();\n    if (imageSize === null) {\n      const imageState = imageStyle.getImageState();\n      if (imageState === ImageState.IDLE || imageState === ImageState.LOADING) {\n        const listener = function () {\n          const imageState = imageStyle.getImageState();\n          if (!(imageState === ImageState.IDLE || imageState === ImageState.LOADING)) {\n            const imageSize = imageStyle.getSize();\n            if (imageSize && imageSize.length == 2) {\n              const resizeScale = scaleForSize(imageSize);\n              imageStyle.setScale(imageScale * resizeScale);\n            }\n            imageStyle.unlistenImageChange(listener);\n          }\n        };\n        imageStyle.listenImageChange(listener);\n        if (imageState === ImageState.IDLE) {\n          imageStyle.load();\n        }\n      }\n    } else if (imageSize.length == 2) {\n      const resizeScale = scaleForSize(imageSize);\n      imageStyle.setScale(imageScale * resizeScale);\n    }\n    styleObject['imageStyle'] = imageStyle;\n  } else {\n    // handle the case when we explicitly want to draw no icon.\n    styleObject['imageStyle'] = DEFAULT_NO_IMAGE_STYLE;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'scale': makeObjectPropertySetter(readScale)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction labelStyleParser(node, objectStack) {\n  // FIXME colorMode\n  const object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const textStyle = new Text({\n    fill: new Fill({\n      color: /** @type {import(\"../color.js\").Color} */\n      'color' in object ? object['color'] : DEFAULT_COLOR\n    }),\n    scale: /** @type {number|undefined} */object['scale']\n  });\n  styleObject['textStyle'] = textStyle;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LINE_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'width': makeObjectPropertySetter(readDecimal)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction lineStyleParser(node, objectStack) {\n  // FIXME colorMode\n  // FIXME gx:outerColor\n  // FIXME gx:outerWidth\n  // FIXME gx:physicalWidth\n  // FIXME gx:labelVisibility\n  const object = pushParseAndPop({}, LINE_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const strokeStyle = new Stroke({\n    color: /** @type {import(\"../color.js\").Color} */\n    'color' in object ? object['color'] : DEFAULT_COLOR,\n    width: /** @type {number} */'width' in object ? object['width'] : 1\n  });\n  styleObject['strokeStyle'] = strokeStyle;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst POLY_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'fill': makeObjectPropertySetter(readBoolean),\n  'outline': makeObjectPropertySetter(readBoolean)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction polyStyleParser(node, objectStack) {\n  // FIXME colorMode\n  const object = pushParseAndPop({}, POLY_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const fillStyle = new Fill({\n    color: /** @type {import(\"../color.js\").Color} */\n    'color' in object ? object['color'] : DEFAULT_COLOR\n  });\n  styleObject['fillStyle'] = fillStyle;\n  const fill = /** @type {boolean|undefined} */object['fill'];\n  if (fill !== undefined) {\n    styleObject['fill'] = fill;\n  }\n  const outline = /** @type {boolean|undefined} */object['outline'];\n  if (outline !== undefined) {\n    styleObject['outline'] = outline;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst FLAT_LINEAR_RING_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'coordinates': makeReplacer(readFlatCoordinates)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<number>} LinearRing flat coordinates.\n */\nfunction readFlatLinearRing(node, objectStack) {\n  return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction gxCoordParser(node, objectStack) {\n  const gxTrackObject = /** @type {GxTrackObject} */\n  objectStack[objectStack.length - 1];\n  const coordinates = gxTrackObject.coordinates;\n  const s = getAllTextContent(node, false);\n  const re = /^\\s*([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s*$/i;\n  const m = re.exec(s);\n  if (m) {\n    const x = parseFloat(m[1]);\n    const y = parseFloat(m[2]);\n    const z = parseFloat(m[3]);\n    coordinates.push([x, y, z]);\n  } else {\n    coordinates.push([]);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {\n  'Track': makeArrayPusher(readGxTrack)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {MultiLineString|undefined} MultiLineString.\n */\nfunction readGxMultiTrack(node, objectStack) {\n  const lineStrings = pushParseAndPop([], GX_MULTITRACK_GEOMETRY_PARSERS, node, objectStack);\n  if (!lineStrings) {\n    return undefined;\n  }\n  return new MultiLineString(lineStrings);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GX_TRACK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'when': whenParser\n}, makeStructureNS(GX_NAMESPACE_URIS, {\n  'coord': gxCoordParser\n}));\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {LineString|undefined} LineString.\n */\nfunction readGxTrack(node, objectStack) {\n  const gxTrackObject = pushParseAndPop( /** @type {GxTrackObject} */{\n    coordinates: [],\n    whens: []\n  }, GX_TRACK_PARSERS, node, objectStack);\n  if (!gxTrackObject) {\n    return undefined;\n  }\n  const flatCoordinates = [];\n  const coordinates = gxTrackObject.coordinates;\n  const whens = gxTrackObject.whens;\n  for (let i = 0, ii = Math.min(coordinates.length, whens.length); i < ii; ++i) {\n    if (coordinates[i].length == 3) {\n      flatCoordinates.push(coordinates[i][0], coordinates[i][1], coordinates[i][2], whens[i]);\n    }\n  }\n  return new LineString(flatCoordinates, 'XYZM');\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ICON_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'href': makeObjectPropertySetter(readURI)\n}, makeStructureNS(GX_NAMESPACE_URIS, {\n  'x': makeObjectPropertySetter(readDecimal),\n  'y': makeObjectPropertySetter(readDecimal),\n  'w': makeObjectPropertySetter(readDecimal),\n  'h': makeObjectPropertySetter(readDecimal)\n}));\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object} Icon object.\n */\nfunction readIcon(node, objectStack) {\n  const iconObject = pushParseAndPop({}, ICON_PARSERS, node, objectStack);\n  if (iconObject) {\n    return iconObject;\n  } else {\n    return null;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'coordinates': makeReplacer(readFlatCoordinates)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<number>} Flat coordinates.\n */\nfunction readFlatCoordinatesFromNode(node, objectStack) {\n  return pushParseAndPop(null, GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'extrude': makeObjectPropertySetter(readBoolean),\n  'tessellate': makeObjectPropertySetter(readBoolean),\n  'altitudeMode': makeObjectPropertySetter(readString)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {LineString|undefined} LineString.\n */\nfunction readLineString(node, objectStack) {\n  const properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const lineString = new LineString(flatCoordinates, 'XYZ');\n    lineString.setProperties(properties, true);\n    return lineString;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Polygon|undefined} Polygon.\n */\nfunction readLinearRing(node, objectStack) {\n  const properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const polygon = new Polygon(flatCoordinates, 'XYZ', [flatCoordinates.length]);\n    polygon.setProperties(properties, true);\n    return polygon;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst MULTI_GEOMETRY_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LineString': makeArrayPusher(readLineString),\n  'LinearRing': makeArrayPusher(readLinearRing),\n  'MultiGeometry': makeArrayPusher(readMultiGeometry),\n  'Point': makeArrayPusher(readPoint),\n  'Polygon': makeArrayPusher(readPolygon)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readMultiGeometry(node, objectStack) {\n  const geometries = pushParseAndPop([], MULTI_GEOMETRY_PARSERS, node, objectStack);\n  if (!geometries) {\n    return null;\n  }\n  if (geometries.length === 0) {\n    return new GeometryCollection(geometries);\n  }\n  let multiGeometry;\n  let homogeneous = true;\n  const type = geometries[0].getType();\n  let geometry;\n  for (let i = 1, ii = geometries.length; i < ii; ++i) {\n    geometry = geometries[i];\n    if (geometry.getType() != type) {\n      homogeneous = false;\n      break;\n    }\n  }\n  if (homogeneous) {\n    let layout;\n    let flatCoordinates;\n    if (type == 'Point') {\n      const point = geometries[0];\n      layout = point.getLayout();\n      flatCoordinates = point.getFlatCoordinates();\n      for (let i = 1, ii = geometries.length; i < ii; ++i) {\n        geometry = geometries[i];\n        extend(flatCoordinates, geometry.getFlatCoordinates());\n      }\n      multiGeometry = new MultiPoint(flatCoordinates, layout);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'LineString') {\n      multiGeometry = new MultiLineString(geometries);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'Polygon') {\n      multiGeometry = new MultiPolygon(geometries);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'GeometryCollection') {\n      multiGeometry = new GeometryCollection(geometries);\n    } else {\n      assert(false, 37); // Unknown geometry type found\n    }\n  } else {\n    multiGeometry = new GeometryCollection(geometries);\n  }\n  return (/** @type {import(\"../geom/Geometry.js\").default} */multiGeometry\n  );\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Point|undefined} Point.\n */\nfunction readPoint(node, objectStack) {\n  const properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const point = new Point(flatCoordinates, 'XYZ');\n    point.setProperties(properties, true);\n    return point;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'innerBoundaryIs': innerBoundaryIsParser,\n  'outerBoundaryIs': outerBoundaryIsParser\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Polygon|undefined} Polygon.\n */\nfunction readPolygon(node, objectStack) {\n  const properties = pushParseAndPop( /** @type {Object<string,*>} */{}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);\n  const flatLinearRings = pushParseAndPop([null], FLAT_LINEAR_RINGS_PARSERS, node, objectStack);\n  if (flatLinearRings && flatLinearRings[0]) {\n    const flatCoordinates = flatLinearRings[0];\n    const ends = [flatCoordinates.length];\n    for (let i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n      extend(flatCoordinates, flatLinearRings[i]);\n      ends.push(flatCoordinates.length);\n    }\n    const polygon = new Polygon(flatCoordinates, 'XYZ', ends);\n    polygon.setProperties(properties, true);\n    return polygon;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'IconStyle': iconStyleParser,\n  'LabelStyle': labelStyleParser,\n  'LineStyle': lineStyleParser,\n  'PolyStyle': polyStyleParser\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<Style>} Style.\n */\nfunction readStyle(node, objectStack) {\n  const styleObject = pushParseAndPop({}, STYLE_PARSERS, node, objectStack, this);\n  if (!styleObject) {\n    return null;\n  }\n  let fillStyle = /** @type {Fill} */\n\n  'fillStyle' in styleObject ? styleObject['fillStyle'] : DEFAULT_FILL_STYLE;\n  const fill = /** @type {boolean|undefined} */styleObject['fill'];\n  if (fill !== undefined && !fill) {\n    fillStyle = null;\n  }\n  let imageStyle;\n  if ('imageStyle' in styleObject) {\n    if (styleObject['imageStyle'] != DEFAULT_NO_IMAGE_STYLE) {\n      imageStyle = styleObject['imageStyle'];\n    }\n  } else {\n    imageStyle = DEFAULT_IMAGE_STYLE;\n  }\n  const textStyle = /** @type {Text} */\n\n  'textStyle' in styleObject ? styleObject['textStyle'] : DEFAULT_TEXT_STYLE;\n  const strokeStyle = /** @type {Stroke} */\n\n  'strokeStyle' in styleObject ? styleObject['strokeStyle'] : DEFAULT_STROKE_STYLE;\n  const outline = /** @type {boolean|undefined} */styleObject['outline'];\n  if (outline !== undefined && !outline) {\n    // if the polystyle specifies no outline two styles are needed,\n    // one for non-polygon geometries where linestrings require a stroke\n    // and one for polygons where there should be no stroke\n    return [new Style({\n      geometry: function (feature) {\n        const geometry = feature.getGeometry();\n        const type = geometry.getType();\n        if (type === 'GeometryCollection') {\n          const collection = /** @type {import(\"../geom/GeometryCollection\").default} */\n          geometry;\n          return new GeometryCollection(collection.getGeometriesArrayRecursive().filter(function (geometry) {\n            const type = geometry.getType();\n            return type !== 'Polygon' && type !== 'MultiPolygon';\n          }));\n        } else if (type !== 'Polygon' && type !== 'MultiPolygon') {\n          return geometry;\n        }\n      },\n      fill: fillStyle,\n      image: imageStyle,\n      stroke: strokeStyle,\n      text: textStyle,\n      zIndex: undefined // FIXME\n    }), new Style({\n      geometry: function (feature) {\n        const geometry = feature.getGeometry();\n        const type = geometry.getType();\n        if (type === 'GeometryCollection') {\n          const collection = /** @type {import(\"../geom/GeometryCollection\").default} */\n          geometry;\n          return new GeometryCollection(collection.getGeometriesArrayRecursive().filter(function (geometry) {\n            const type = geometry.getType();\n            return type === 'Polygon' || type === 'MultiPolygon';\n          }));\n        } else if (type === 'Polygon' || type === 'MultiPolygon') {\n          return geometry;\n        }\n      },\n      fill: fillStyle,\n      stroke: null,\n      zIndex: undefined // FIXME\n    })];\n  }\n\n  return [new Style({\n    fill: fillStyle,\n    image: imageStyle,\n    stroke: strokeStyle,\n    text: textStyle,\n    zIndex: undefined // FIXME\n  })];\n}\n\n/**\n * Reads an array of geometries and creates arrays for common geometry\n * properties. Then sets them to the multi geometry.\n * @param {MultiPoint|MultiLineString|MultiPolygon} multiGeometry A multi-geometry.\n * @param {Array<import(\"../geom/Geometry.js\").default>} geometries List of geometries.\n */\nfunction setCommonGeometryProperties(multiGeometry, geometries) {\n  const ii = geometries.length;\n  const extrudes = new Array(geometries.length);\n  const tessellates = new Array(geometries.length);\n  const altitudeModes = new Array(geometries.length);\n  let hasExtrude, hasTessellate, hasAltitudeMode;\n  hasExtrude = false;\n  hasTessellate = false;\n  hasAltitudeMode = false;\n  for (let i = 0; i < ii; ++i) {\n    const geometry = geometries[i];\n    extrudes[i] = geometry.get('extrude');\n    tessellates[i] = geometry.get('tessellate');\n    altitudeModes[i] = geometry.get('altitudeMode');\n    hasExtrude = hasExtrude || extrudes[i] !== undefined;\n    hasTessellate = hasTessellate || tessellates[i] !== undefined;\n    hasAltitudeMode = hasAltitudeMode || altitudeModes[i];\n  }\n  if (hasExtrude) {\n    multiGeometry.set('extrude', extrudes);\n  }\n  if (hasTessellate) {\n    multiGeometry.set('tessellate', tessellates);\n  }\n  if (hasAltitudeMode) {\n    multiGeometry.set('altitudeMode', altitudeModes);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'displayName': makeObjectPropertySetter(readString),\n  'value': makeObjectPropertySetter(readString)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction dataParser(node, objectStack) {\n  const name = node.getAttribute('name');\n  parseNode(DATA_PARSERS, node, objectStack);\n  const featureObject = /** @type {Object} */\n  objectStack[objectStack.length - 1];\n  if (name && featureObject.displayName) {\n    featureObject[name] = {\n      value: featureObject.value,\n      displayName: featureObject.displayName,\n      toString: function () {\n        return featureObject.value;\n      }\n    };\n  } else if (name !== null) {\n    featureObject[name] = featureObject.value;\n  } else if (featureObject.displayName !== null) {\n    featureObject[featureObject.displayName] = featureObject.value;\n  }\n  delete featureObject['value'];\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst EXTENDED_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Data': dataParser,\n  'SchemaData': schemaDataParser\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction extendedDataParser(node, objectStack) {\n  parseNode(EXTENDED_DATA_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction regionParser(node, objectStack) {\n  parseNode(REGION_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PAIR_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Style': makeObjectPropertySetter(readStyle),\n  'key': makeObjectPropertySetter(readString),\n  'styleUrl': makeObjectPropertySetter(readStyleURL)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction pairDataParser(node, objectStack) {\n  const pairObject = pushParseAndPop({}, PAIR_PARSERS, node, objectStack, this);\n  if (!pairObject) {\n    return;\n  }\n  const key = /** @type {string|undefined} */pairObject['key'];\n  if (key && key == 'normal') {\n    const styleUrl = /** @type {string|undefined} */pairObject['styleUrl'];\n    if (styleUrl) {\n      objectStack[objectStack.length - 1] = styleUrl;\n    }\n    const style = /** @type {Style} */pairObject['Style'];\n    if (style) {\n      objectStack[objectStack.length - 1] = style;\n    }\n  }\n}\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction placemarkStyleMapParser(node, objectStack) {\n  const styleMapValue = readStyleMapValue.call(this, node, objectStack);\n  if (!styleMapValue) {\n    return;\n  }\n  const placemarkObject = objectStack[objectStack.length - 1];\n  if (Array.isArray(styleMapValue)) {\n    placemarkObject['Style'] = styleMapValue;\n  } else if (typeof styleMapValue === 'string') {\n    placemarkObject['styleUrl'] = styleMapValue;\n  } else {\n    assert(false, 38); // `styleMapValue` has an unknown type\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst SCHEMA_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'SimpleData': simpleDataParser\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction schemaDataParser(node, objectStack) {\n  parseNode(SCHEMA_DATA_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction simpleDataParser(node, objectStack) {\n  const name = node.getAttribute('name');\n  if (name !== null) {\n    const data = readString(node);\n    const featureObject = /** @type {Object} */\n    objectStack[objectStack.length - 1];\n    featureObject[name] = data;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LAT_LON_ALT_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'altitudeMode': makeObjectPropertySetter(readString),\n  'minAltitude': makeObjectPropertySetter(readDecimal),\n  'maxAltitude': makeObjectPropertySetter(readDecimal),\n  'north': makeObjectPropertySetter(readDecimal),\n  'south': makeObjectPropertySetter(readDecimal),\n  'east': makeObjectPropertySetter(readDecimal),\n  'west': makeObjectPropertySetter(readDecimal)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction latLonAltBoxParser(node, objectStack) {\n  const object = pushParseAndPop({}, LAT_LON_ALT_BOX_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const regionObject = /** @type {Object} */\n  objectStack[objectStack.length - 1];\n  const extent = [parseFloat(object['west']), parseFloat(object['south']), parseFloat(object['east']), parseFloat(object['north'])];\n  regionObject['extent'] = extent;\n  regionObject['altitudeMode'] = object['altitudeMode'];\n  regionObject['minAltitude'] = parseFloat(object['minAltitude']);\n  regionObject['maxAltitude'] = parseFloat(object['maxAltitude']);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LOD_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'minLodPixels': makeObjectPropertySetter(readDecimal),\n  'maxLodPixels': makeObjectPropertySetter(readDecimal),\n  'minFadeExtent': makeObjectPropertySetter(readDecimal),\n  'maxFadeExtent': makeObjectPropertySetter(readDecimal)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction lodParser(node, objectStack) {\n  const object = pushParseAndPop({}, LOD_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const lodObject = /** @type {Object} */objectStack[objectStack.length - 1];\n  lodObject['minLodPixels'] = parseFloat(object['minLodPixels']);\n  lodObject['maxLodPixels'] = parseFloat(object['maxLodPixels']);\n  lodObject['minFadeExtent'] = parseFloat(object['minFadeExtent']);\n  lodObject['maxFadeExtent'] = parseFloat(object['maxFadeExtent']);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst INNER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth\n  // allows multiple, so we parse multiple here too.\n  'LinearRing': makeArrayPusher(readFlatLinearRing)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction innerBoundaryIsParser(node, objectStack) {\n  const innerBoundaryFlatLinearRings = pushParseAndPop( /** @type {Array<Array<number>>} */[], INNER_BOUNDARY_IS_PARSERS, node, objectStack);\n  if (innerBoundaryFlatLinearRings.length > 0) {\n    const flatLinearRings = /** @type {Array<Array<number>>} */\n    objectStack[objectStack.length - 1];\n    flatLinearRings.push(...innerBoundaryFlatLinearRings);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LinearRing': makeReplacer(readFlatLinearRing)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction outerBoundaryIsParser(node, objectStack) {\n  /** @type {Array<number>|undefined} */\n  const flatLinearRing = pushParseAndPop(undefined, OUTER_BOUNDARY_IS_PARSERS, node, objectStack);\n  if (flatLinearRing) {\n    const flatLinearRings = /** @type {Array<Array<number>>} */\n    objectStack[objectStack.length - 1];\n    flatLinearRings[0] = flatLinearRing;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction linkParser(node, objectStack) {\n  parseNode(LINK_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction whenParser(node, objectStack) {\n  const gxTrackObject = /** @type {GxTrackObject} */\n  objectStack[objectStack.length - 1];\n  const whens = gxTrackObject.whens;\n  const s = getAllTextContent(node, false);\n  const when = Date.parse(s);\n  whens.push(isNaN(when) ? 0 : when);\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the color to.\n * @param {import(\"../color.js\").Color|string} color Color.\n */\nfunction writeColorTextNode(node, color) {\n  const rgba = asArray(color);\n  const opacity = rgba.length == 4 ? rgba[3] : 1;\n  /** @type {Array<string|number>} */\n  const abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];\n  for (let i = 0; i < 4; ++i) {\n    const hex = Math.floor( /** @type {number} */abgr[i]).toString(16);\n    abgr[i] = hex.length == 1 ? '0' + hex : hex;\n  }\n  writeStringTextNode(node, abgr.join(''));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the coordinates to.\n * @param {Array<number>} coordinates Coordinates.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeCoordinatesTextNode(node, coordinates, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const layout = context['layout'];\n  const stride = context['stride'];\n  let dimension;\n  if (layout == 'XY' || layout == 'XYM') {\n    dimension = 2;\n  } else if (layout == 'XYZ' || layout == 'XYZM') {\n    dimension = 3;\n  } else {\n    assert(false, 34); // Invalid geometry layout\n  }\n\n  const ii = coordinates.length;\n  let text = '';\n  if (ii > 0) {\n    text += coordinates[0];\n    for (let d = 1; d < dimension; ++d) {\n      text += ',' + coordinates[d];\n    }\n    for (let i = stride; i < ii; i += stride) {\n      text += ' ' + coordinates[i];\n      for (let d = 1; d < dimension; ++d) {\n        text += ',' + coordinates[i + d];\n      }\n    }\n  }\n  writeStringTextNode(node, text);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Data': makeChildAppender(writeDataNode),\n  'value': makeChildAppender(writeDataNodeValue),\n  'displayName': makeChildAppender(writeDataNodeName)\n});\n\n/**\n * @param {Element} node Node.\n * @param {{name: *, value: *}} pair Name value pair.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeDataNode(node, pair, objectStack) {\n  node.setAttribute('name', pair.name);\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const value = pair.value;\n  if (typeof value == 'object') {\n    if (value !== null && value.displayName) {\n      pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, ['displayName']);\n    }\n    if (value !== null && value.value) {\n      pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, ['value']);\n    }\n  } else {\n    pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, ['value']);\n  }\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the name to.\n * @param {string} name DisplayName.\n */\nfunction writeDataNodeName(node, name) {\n  writeCDATASection(node, name);\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the value to.\n * @param {string} value Value.\n */\nfunction writeDataNodeValue(node, value) {\n  writeStringTextNode(node, value);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst DOCUMENT_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Placemark': makeChildAppender(writePlacemark)\n});\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst DOCUMENT_NODE_FACTORY = function (value, objectStack, nodeName) {\n  const parentNode = objectStack[objectStack.length - 1].node;\n  return createElementNS(parentNode.namespaceURI, 'Placemark');\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<Feature>} features Features.\n * @param {Array<*>} objectStack Object stack.\n * @this {KML}\n */\nfunction writeDocument(node, features, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  pushSerializeAndPop(context, DOCUMENT_SERIALIZERS, DOCUMENT_NODE_FACTORY, features, objectStack, undefined, this);\n}\n\n/**\n * A factory for creating Data nodes.\n * @const\n * @type {function(*, Array<*>): (Node|undefined)}\n */\nconst DATA_NODE_FACTORY = makeSimpleNodeFactory('Data');\n\n/**\n * @param {Element} node Node.\n * @param {{names: Array<string>, values: (Array<*>)}} namesAndValues Names and values.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeExtendedData(node, namesAndValues, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const names = namesAndValues.names;\n  const values = namesAndValues.values;\n  const length = names.length;\n  for (let i = 0; i < length; i++) {\n    pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, DATA_NODE_FACTORY, [{\n      name: names[i],\n      value: values[i]\n    }], objectStack);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst ICON_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['href'], makeStructureNS(GX_NAMESPACE_URIS, ['x', 'y', 'w', 'h']));\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst ICON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'href': makeChildAppender(writeStringTextNode)\n}, makeStructureNS(GX_NAMESPACE_URIS, {\n  'x': makeChildAppender(writeDecimalTextNode),\n  'y': makeChildAppender(writeDecimalTextNode),\n  'w': makeChildAppender(writeDecimalTextNode),\n  'h': makeChildAppender(writeDecimalTextNode)\n}));\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst GX_NODE_FACTORY = function (value, objectStack, nodeName) {\n  return createElementNS(GX_NAMESPACE_URIS[0], 'gx:' + nodeName);\n};\n\n/**\n * @param {Element} node Node.\n * @param {Object} icon Icon object.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeIcon(node, icon, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const parentNode = objectStack[objectStack.length - 1].node;\n  let orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];\n  let values = makeSequence(icon, orderedKeys);\n  pushSerializeAndPop(context, ICON_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n  orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];\n  values = makeSequence(icon, orderedKeys);\n  pushSerializeAndPop(context, ICON_SERIALIZERS, GX_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst ICON_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['scale', 'heading', 'Icon', 'color', 'hotSpot']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst ICON_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Icon': makeChildAppender(writeIcon),\n  'color': makeChildAppender(writeColorTextNode),\n  'heading': makeChildAppender(writeDecimalTextNode),\n  'hotSpot': makeChildAppender(writeVec2),\n  'scale': makeChildAppender(writeScaleTextNode)\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../style/Icon.js\").default} style Icon style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeIconStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const /** @type {Object<string, any>} */properties = {};\n  const src = style.getSrc();\n  const size = style.getSize();\n  const iconImageSize = style.getImageSize();\n  const iconProperties = {\n    'href': src\n  };\n  if (size) {\n    iconProperties['w'] = size[0];\n    iconProperties['h'] = size[1];\n    const anchor = style.getAnchor(); // top-left\n    const origin = style.getOrigin(); // top-left\n\n    if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {\n      iconProperties['x'] = origin[0];\n      iconProperties['y'] = iconImageSize[1] - (origin[1] + size[1]);\n    }\n    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {\n      const /** @type {Vec2} */hotSpot = {\n        x: anchor[0],\n        xunits: 'pixels',\n        y: size[1] - anchor[1],\n        yunits: 'pixels'\n      };\n      properties['hotSpot'] = hotSpot;\n    }\n  }\n  properties['Icon'] = iconProperties;\n  let scale = style.getScaleArray()[0];\n  let imageSize = size;\n  if (imageSize === null) {\n    imageSize = DEFAULT_IMAGE_STYLE_SIZE;\n  }\n  if (imageSize.length == 2) {\n    const resizeScale = scaleForSize(imageSize);\n    scale = scale / resizeScale;\n  }\n  if (scale !== 1) {\n    properties['scale'] = scale;\n  }\n  const rotation = style.getRotation();\n  if (rotation !== 0) {\n    properties['heading'] = rotation; // 0-360\n  }\n\n  const color = style.getColor();\n  if (color) {\n    properties['color'] = color;\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, ICON_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['color', 'scale']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'scale': makeChildAppender(writeScaleTextNode)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Text} style style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeLabelStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const properties = {};\n  const fill = style.getFill();\n  if (fill) {\n    properties['color'] = fill.getColor();\n  }\n  const scale = style.getScale();\n  if (scale && scale !== 1) {\n    properties['scale'] = scale;\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, LABEL_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst LINE_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['color', 'width']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst LINE_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'width': makeChildAppender(writeDecimalTextNode)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Stroke} style style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeLineStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const properties = {\n    'color': style.getColor(),\n    'width': Number(style.getWidth()) || 1\n  };\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, LINE_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst GEOMETRY_TYPE_TO_NODENAME = {\n  'Point': 'Point',\n  'LineString': 'LineString',\n  'LinearRing': 'LinearRing',\n  'Polygon': 'Polygon',\n  'MultiPoint': 'MultiGeometry',\n  'MultiLineString': 'MultiGeometry',\n  'MultiPolygon': 'MultiGeometry',\n  'GeometryCollection': 'MultiGeometry'\n};\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst GEOMETRY_NODE_FACTORY = function (value, objectStack, nodeName) {\n  if (value) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(parentNode.namespaceURI, GEOMETRY_TYPE_TO_NODENAME[/** @type {import(\"../geom/Geometry.js\").default} */value.getType()]);\n  }\n};\n\n/**\n * A factory for creating Point nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst POINT_NODE_FACTORY = makeSimpleNodeFactory('Point');\n\n/**\n * A factory for creating LineString nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory('LineString');\n\n/**\n * A factory for creating LinearRing nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory('LinearRing');\n\n/**\n * A factory for creating Polygon nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst POLYGON_NODE_FACTORY = makeSimpleNodeFactory('Polygon');\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'LineString': makeChildAppender(writePrimitiveGeometry),\n  'Point': makeChildAppender(writePrimitiveGeometry),\n  'Polygon': makeChildAppender(writePolygon),\n  'GeometryCollection': makeChildAppender(writeMultiGeometry)\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeMultiGeometry(node, geometry, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const context = {\n    node: node\n  };\n  const type = geometry.getType();\n  /** @type {Array<import(\"../geom/Geometry.js\").default>} */\n  let geometries = [];\n  /** @type {function(*, Array<*>, string=): (Node|undefined)} */\n  let factory;\n  if (type === 'GeometryCollection') {\n    /** @type {GeometryCollection} */geometry.getGeometriesArrayRecursive().forEach(function (geometry) {\n      const type = geometry.getType();\n      if (type === 'MultiPoint') {\n        geometries = geometries.concat( /** @type {MultiPoint} */geometry.getPoints());\n      } else if (type === 'MultiLineString') {\n        geometries = geometries.concat( /** @type {MultiLineString} */geometry.getLineStrings());\n      } else if (type === 'MultiPolygon') {\n        geometries = geometries.concat( /** @type {MultiPolygon} */geometry.getPolygons());\n      } else if (type === 'Point' || type === 'LineString' || type === 'Polygon') {\n        geometries.push(geometry);\n      } else {\n        assert(false, 39); // Unknown geometry type\n      }\n    });\n\n    factory = GEOMETRY_NODE_FACTORY;\n  } else if (type === 'MultiPoint') {\n    geometries = /** @type {MultiPoint} */geometry.getPoints();\n    factory = POINT_NODE_FACTORY;\n  } else if (type === 'MultiLineString') {\n    geometries = /** @type {MultiLineString} */geometry.getLineStrings();\n    factory = LINE_STRING_NODE_FACTORY;\n  } else if (type === 'MultiPolygon') {\n    geometries = /** @type {MultiPolygon} */geometry.getPolygons();\n    factory = POLYGON_NODE_FACTORY;\n  } else {\n    assert(false, 39); // Unknown geometry type\n  }\n\n  pushSerializeAndPop(context, MULTI_GEOMETRY_SERIALIZERS, factory, geometries, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst BOUNDARY_IS_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'LinearRing': makeChildAppender(writePrimitiveGeometry)\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/LinearRing.js\").default} linearRing Linear ring.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeBoundaryIs(node, linearRing, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  pushSerializeAndPop(context, BOUNDARY_IS_SERIALIZERS, LINEAR_RING_NODE_FACTORY, [linearRing], objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst PLACEMARK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'ExtendedData': makeChildAppender(writeExtendedData),\n  'MultiGeometry': makeChildAppender(writeMultiGeometry),\n  'LineString': makeChildAppender(writePrimitiveGeometry),\n  'LinearRing': makeChildAppender(writePrimitiveGeometry),\n  'Point': makeChildAppender(writePrimitiveGeometry),\n  'Polygon': makeChildAppender(writePolygon),\n  'Style': makeChildAppender(writeStyle),\n  'address': makeChildAppender(writeStringTextNode),\n  'description': makeChildAppender(writeStringTextNode),\n  'name': makeChildAppender(writeStringTextNode),\n  'open': makeChildAppender(writeBooleanTextNode),\n  'phoneNumber': makeChildAppender(writeStringTextNode),\n  'styleUrl': makeChildAppender(writeStringTextNode),\n  'visibility': makeChildAppender(writeBooleanTextNode)\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst PLACEMARK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['name', 'open', 'visibility', 'address', 'phoneNumber', 'description', 'styleUrl', 'Style']);\n\n/**\n * A factory for creating ExtendedData nodes.\n * @const\n * @type {function(*, Array<*>): (Node|undefined)}\n */\nconst EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory('ExtendedData');\n\n/**\n * FIXME currently we do serialize arbitrary/custom feature properties\n * (ExtendedData).\n * @param {Element} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n * @this {KML}\n */\nfunction writePlacemark(node, feature, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n\n  // set id\n  if (feature.getId()) {\n    node.setAttribute('id', /** @type {string} */feature.getId());\n  }\n\n  // serialize properties (properties unknown to KML are not serialized)\n  const properties = feature.getProperties();\n\n  // don't export these to ExtendedData\n  const filter = {\n    'address': 1,\n    'description': 1,\n    'name': 1,\n    'open': 1,\n    'phoneNumber': 1,\n    'styleUrl': 1,\n    'visibility': 1\n  };\n  filter[feature.getGeometryName()] = 1;\n  const keys = Object.keys(properties || {}).sort().filter(function (v) {\n    return !filter[v];\n  });\n  const styleFunction = feature.getStyleFunction();\n  if (styleFunction) {\n    // FIXME the styles returned by the style function are supposed to be\n    // resolution-independent here\n    const styles = styleFunction(feature, 0);\n    if (styles) {\n      const styleArray = Array.isArray(styles) ? styles : [styles];\n      let pointStyles = styleArray;\n      if (feature.getGeometry()) {\n        pointStyles = styleArray.filter(function (style) {\n          const geometry = style.getGeometryFunction()(feature);\n          if (geometry) {\n            const type = geometry.getType();\n            if (type === 'GeometryCollection') {\n              return (/** @type {GeometryCollection} */geometry.getGeometriesArrayRecursive().filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type === 'Point' || type === 'MultiPoint';\n                }).length\n              );\n            }\n            return type === 'Point' || type === 'MultiPoint';\n          }\n        });\n        'Point';\n      }\n      if (this.writeStyles_) {\n        let lineStyles = styleArray;\n        let polyStyles = styleArray;\n        if (feature.getGeometry()) {\n          lineStyles = styleArray.filter(function (style) {\n            const geometry = style.getGeometryFunction()(feature);\n            if (geometry) {\n              const type = geometry.getType();\n              if (type === 'GeometryCollection') {\n                return (/** @type {GeometryCollection} */geometry.getGeometriesArrayRecursive().filter(function (geometry) {\n                    const type = geometry.getType();\n                    return type === 'LineString' || type === 'MultiLineString';\n                  }).length\n                );\n              }\n              return type === 'LineString' || type === 'MultiLineString';\n            }\n          });\n          polyStyles = styleArray.filter(function (style) {\n            const geometry = style.getGeometryFunction()(feature);\n            if (geometry) {\n              const type = geometry.getType();\n              if (type === 'GeometryCollection') {\n                return (/** @type {GeometryCollection} */geometry.getGeometriesArrayRecursive().filter(function (geometry) {\n                    const type = geometry.getType();\n                    return type === 'Polygon' || type === 'MultiPolygon';\n                  }).length\n                );\n              }\n              return type === 'Polygon' || type === 'MultiPolygon';\n            }\n          });\n        }\n        properties['Style'] = {\n          pointStyles: pointStyles,\n          lineStyles: lineStyles,\n          polyStyles: polyStyles\n        };\n      }\n      if (pointStyles.length && properties['name'] === undefined) {\n        const textStyle = pointStyles[0].getText();\n        if (textStyle) {\n          properties['name'] = textStyle.getText();\n        }\n      }\n    }\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n  if (keys.length > 0) {\n    const sequence = makeSequence(properties, keys);\n    const namesAndValues = {\n      names: keys,\n      values: sequence\n    };\n    pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, EXTENDEDDATA_NODE_FACTORY, [namesAndValues], objectStack);\n  }\n\n  // serialize geometry\n  const options = /** @type {import(\"./Feature.js\").WriteOptions} */\n  objectStack[0];\n  let geometry = feature.getGeometry();\n  if (geometry) {\n    geometry = transformGeometryWithOptions(geometry, true, options);\n  }\n  pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, GEOMETRY_NODE_FACTORY, [geometry], objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['extrude', 'tessellate', 'altitudeMode', 'coordinates']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'extrude': makeChildAppender(writeBooleanTextNode),\n  'tessellate': makeChildAppender(writeBooleanTextNode),\n  'altitudeMode': makeChildAppender(writeStringTextNode),\n  'coordinates': makeChildAppender(writeCoordinatesTextNode)\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePrimitiveGeometry(node, geometry, objectStack) {\n  const flatCoordinates = geometry.getFlatCoordinates();\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  context['layout'] = geometry.getLayout();\n  context['stride'] = geometry.getStride();\n\n  // serialize properties (properties unknown to KML are not serialized)\n  const properties = geometry.getProperties();\n  properties.coordinates = flatCoordinates;\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, PRIMITIVE_GEOMETRY_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst POLY_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['color', 'fill', 'outline']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst POLYGON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'outerBoundaryIs': makeChildAppender(writeBoundaryIs),\n  'innerBoundaryIs': makeChildAppender(writeBoundaryIs)\n});\n\n/**\n * A factory for creating innerBoundaryIs nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('innerBoundaryIs');\n\n/**\n * A factory for creating outerBoundaryIs nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('outerBoundaryIs');\n\n/**\n * @param {Element} node Node.\n * @param {Polygon} polygon Polygon.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePolygon(node, polygon, objectStack) {\n  const linearRings = polygon.getLinearRings();\n  const outerRing = linearRings.shift();\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  // inner rings\n  pushSerializeAndPop(context, POLYGON_SERIALIZERS, INNER_BOUNDARY_NODE_FACTORY, linearRings, objectStack);\n  // outer ring\n  pushSerializeAndPop(context, POLYGON_SERIALIZERS, OUTER_BOUNDARY_NODE_FACTORY, [outerRing], objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst POLY_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'fill': makeChildAppender(writeBooleanTextNode),\n  'outline': makeChildAppender(writeBooleanTextNode)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Style} style Style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePolyStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const fill = style.getFill();\n  const stroke = style.getStroke();\n  const properties = {\n    'color': fill ? fill.getColor() : undefined,\n    'fill': fill ? undefined : false,\n    'outline': stroke ? undefined : false\n  };\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, POLY_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the scale to.\n * @param {number|undefined} scale Scale.\n */\nfunction writeScaleTextNode(node, scale) {\n  // the Math is to remove any excess decimals created by float arithmetic\n  writeDecimalTextNode(node, Math.round(scale * 1e6) / 1e6);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['IconStyle', 'LabelStyle', 'LineStyle', 'PolyStyle']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'IconStyle': makeChildAppender(writeIconStyle),\n  'LabelStyle': makeChildAppender(writeLabelStyle),\n  'LineStyle': makeChildAppender(writeLineStyle),\n  'PolyStyle': makeChildAppender(writePolyStyle)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Object<string, Array<Style>>} styles Styles.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeStyle(node, styles, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const properties = {};\n  if (styles.pointStyles.length) {\n    const textStyle = styles.pointStyles[0].getText();\n    if (textStyle) {\n      properties['LabelStyle'] = textStyle;\n    }\n    const imageStyle = styles.pointStyles[0].getImage();\n    if (imageStyle && typeof /** @type {?} */imageStyle.getSrc === 'function') {\n      properties['IconStyle'] = imageStyle;\n    }\n  }\n  if (styles.lineStyles.length) {\n    const strokeStyle = styles.lineStyles[0].getStroke();\n    if (strokeStyle) {\n      properties['LineStyle'] = strokeStyle;\n    }\n  }\n  if (styles.polyStyles.length) {\n    const strokeStyle = styles.polyStyles[0].getStroke();\n    if (strokeStyle && !properties['LineStyle']) {\n      properties['LineStyle'] = strokeStyle;\n    }\n    properties['PolyStyle'] = styles.polyStyles[0];\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n\n/**\n * @param {Element} node Node to append a TextNode with the Vec2 to.\n * @param {Vec2} vec2 Vec2.\n */\nfunction writeVec2(node, vec2) {\n  node.setAttribute('x', String(vec2.x));\n  node.setAttribute('y', String(vec2.y));\n  node.setAttribute('xunits', vec2.xunits);\n  node.setAttribute('yunits', vec2.yunits);\n}\nexport default KML;","map":{"version":3,"names":["Feature","Fill","GeometryCollection","Icon","ImageState","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","Stroke","Style","Text","XMLFeature","OBJECT_PROPERTY_NODE_FACTORY","XML_SCHEMA_INSTANCE_URI","createElementNS","getAllTextContent","isDocument","makeArrayExtender","makeArrayPusher","makeChildAppender","makeObjectPropertySetter","makeReplacer","makeSequence","makeSimpleNodeFactory","makeStructureNS","parse","parseNode","pushParseAndPop","pushSerializeAndPop","asArray","assert","extend","get","getProjection","readBoolean","readDecimal","readString","writeBooleanTextNode","writeCDATASection","writeDecimalTextNode","writeStringTextNode","toRadians","transformGeometryWithOptions","GX_NAMESPACE_URIS","NAMESPACE_URIS","SCHEMA_LOCATION","ICON_ANCHOR_UNITS_MAP","PLACEMARK_PARSERS","extendedDataParser","regionParser","readMultiGeometry","readLineString","readLinearRing","readPoint","readPolygon","readStyle","placemarkStyleMapParser","readStyleURL","readGxMultiTrack","readGxTrack","NETWORK_LINK_PARSERS","linkParser","LINK_PARSERS","readURI","REGION_PARSERS","latLonAltBoxParser","lodParser","KML_SEQUENCE","KML_SERIALIZERS","writeDocument","writePlacemark","DEFAULT_COLOR","DEFAULT_FILL_STYLE","getDefaultFillStyle","DEFAULT_IMAGE_STYLE_ANCHOR","DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS","DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS","DEFAULT_IMAGE_STYLE_SIZE","DEFAULT_IMAGE_STYLE_SRC","DEFAULT_IMAGE_STYLE","getDefaultImageStyle","DEFAULT_NO_IMAGE_STYLE","DEFAULT_STROKE_STYLE","getDefaultStrokeStyle","DEFAULT_TEXT_STROKE_STYLE","DEFAULT_TEXT_STYLE","getDefaultTextStyle","DEFAULT_STYLE","getDefaultStyle","DEFAULT_STYLE_ARRAY","getDefaultStyleArray","scaleForSize","size","Math","min","createStyleDefaults","color","anchor","anchorOrigin","anchorXUnits","anchorYUnits","crossOrigin","rotation","scale","src","width","font","fill","stroke","image","text","zIndex","TEXTAREA","defaultIconUrlFunction","href","KML","constructor","options","dataProjection","defaultStyle_","defaultStyle","extractStyles_","extractStyles","undefined","writeStyles_","writeStyles","sharedStyles_","showPointNames_","showPointNames","crossOrigin_","iconUrlFunction_","iconUrlFunction","supportedMediaTypes","readDocumentOrFolder_","node","objectStack","parsersNS","readPlacemark_","readSharedStyle_","bind","readSharedStyleMap_","features","object","feature","id","getAttribute","setId","geometry","setGeometry","style","styleUrl","styleFunction","createFeatureStyleFunction","setStyle","setProperties","call","styleUri","baseURI","window","location","url","URL","styleMapValue","readStyleMapValue","readFeatureFromNode","includes","namespaceURI","getReadOptions","readFeaturesFromNode","localName","n","firstElementChild","nextElementSibling","fs","readName","source","doc","readNameFromDocument","readNameFromNode","firstChild","nextSibling","nodeType","Node","ELEMENT_NODE","name","readNetworkLinks","networkLinks","readNetworkLinksFromDocument","readNetworkLinksFromNode","obj","push","readRegion","regions","readRegionFromDocument","readRegionFromNode","writeFeaturesNode","adaptOptions","kml","xmlnsUri","setAttributeNS","context","properties","length","orderedKeys","values","createNameStyleFunction","foundStyle","textOffset","textAlign","imageStyle","getImage","imageSize","getSize","imageScale","getScaleArray","getAnchor","textStyle","getText","clone","setFont","getFont","setScale","getScale","setFill","getFill","setStroke","getStroke","setText","setOffsetX","setOffsetY","setTextAlign","nameStyle","sharedStyles","resolution","drawName","multiGeometryPoints","getGeometry","getGeometriesArrayRecursive","filter","type","getType","test","document","createElement","innerHTML","value","featureStyle","findStyle","baseStyle","concat","slice","styleValue","Array","isArray","readColor","s","m","exec","hexColor","parseInt","substr","readFlatCoordinates","flatCoordinates","replace","re","x","parseFloat","y","z","trim","readVec2","xunits","yunits","origin","readScale","STYLE_MAP_PARSERS","pairDataParser","ICON_STYLE_PARSERS","readIcon","iconStyleParser","styleObject","IconObject","drawIcon","Object","keys","hotSpot","offset","w","h","heading","offsetOrigin","imageState","getImageState","IDLE","LOADING","listener","resizeScale","unlistenImageChange","listenImageChange","load","LABEL_STYLE_PARSERS","labelStyleParser","LINE_STYLE_PARSERS","lineStyleParser","strokeStyle","POLY_STYLE_PARSERS","polyStyleParser","fillStyle","outline","FLAT_LINEAR_RING_PARSERS","readFlatLinearRing","gxCoordParser","gxTrackObject","coordinates","GX_MULTITRACK_GEOMETRY_PARSERS","lineStrings","GX_TRACK_PARSERS","whenParser","whens","i","ii","ICON_PARSERS","iconObject","GEOMETRY_FLAT_COORDINATES_PARSERS","readFlatCoordinatesFromNode","EXTRUDE_AND_ALTITUDE_MODE_PARSERS","lineString","polygon","MULTI_GEOMETRY_PARSERS","geometries","multiGeometry","homogeneous","layout","point","getLayout","getFlatCoordinates","setCommonGeometryProperties","FLAT_LINEAR_RINGS_PARSERS","innerBoundaryIsParser","outerBoundaryIsParser","flatLinearRings","ends","STYLE_PARSERS","collection","extrudes","tessellates","altitudeModes","hasExtrude","hasTessellate","hasAltitudeMode","set","DATA_PARSERS","dataParser","featureObject","displayName","toString","EXTENDED_DATA_PARSERS","schemaDataParser","PAIR_PARSERS","pairObject","key","placemarkObject","SCHEMA_DATA_PARSERS","simpleDataParser","data","LAT_LON_ALT_BOX_PARSERS","regionObject","extent","LOD_PARSERS","lodObject","INNER_BOUNDARY_IS_PARSERS","innerBoundaryFlatLinearRings","OUTER_BOUNDARY_IS_PARSERS","flatLinearRing","when","Date","isNaN","writeColorTextNode","rgba","opacity","abgr","hex","floor","join","writeCoordinatesTextNode","stride","dimension","d","EXTENDEDDATA_NODE_SERIALIZERS","writeDataNode","writeDataNodeValue","writeDataNodeName","pair","setAttribute","DOCUMENT_SERIALIZERS","DOCUMENT_NODE_FACTORY","nodeName","parentNode","DATA_NODE_FACTORY","writeExtendedData","namesAndValues","names","ICON_SEQUENCE","ICON_SERIALIZERS","GX_NODE_FACTORY","writeIcon","icon","ICON_STYLE_SEQUENCE","ICON_STYLE_SERIALIZERS","writeVec2","writeScaleTextNode","writeIconStyle","getSrc","iconImageSize","getImageSize","iconProperties","getOrigin","getRotation","getColor","LABEL_STYLE_SEQUENCE","LABEL_STYLE_SERIALIZERS","writeLabelStyle","LINE_STYLE_SEQUENCE","LINE_STYLE_SERIALIZERS","writeLineStyle","Number","getWidth","GEOMETRY_TYPE_TO_NODENAME","GEOMETRY_NODE_FACTORY","POINT_NODE_FACTORY","LINE_STRING_NODE_FACTORY","LINEAR_RING_NODE_FACTORY","POLYGON_NODE_FACTORY","MULTI_GEOMETRY_SERIALIZERS","writePrimitiveGeometry","writePolygon","writeMultiGeometry","factory","forEach","getPoints","getLineStrings","getPolygons","BOUNDARY_IS_SERIALIZERS","writeBoundaryIs","linearRing","PLACEMARK_SERIALIZERS","writeStyle","PLACEMARK_SEQUENCE","EXTENDEDDATA_NODE_FACTORY","getId","getProperties","getGeometryName","sort","v","getStyleFunction","styles","styleArray","pointStyles","getGeometryFunction","lineStyles","polyStyles","sequence","PRIMITIVE_GEOMETRY_SEQUENCE","PRIMITIVE_GEOMETRY_SERIALIZERS","getStride","POLY_STYLE_SEQUENCE","POLYGON_SERIALIZERS","INNER_BOUNDARY_NODE_FACTORY","OUTER_BOUNDARY_NODE_FACTORY","linearRings","getLinearRings","outerRing","shift","POLY_STYLE_SERIALIZERS","writePolyStyle","round","STYLE_SEQUENCE","STYLE_SERIALIZERS","vec2","String"],"sources":["/Users/lydiaprice/quake-text/Frontend/node_modules/ol/format/KML.js"],"sourcesContent":["/**\n * @module ol/format/KML\n */\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport Icon from '../style/Icon.js';\nimport ImageState from '../ImageState.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport XMLFeature from './XMLFeature.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  getAllTextContent,\n  isDocument,\n  makeArrayExtender,\n  makeArrayPusher,\n  makeChildAppender,\n  makeObjectPropertySetter,\n  makeReplacer,\n  makeSequence,\n  makeSimpleNodeFactory,\n  makeStructureNS,\n  parse,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {asArray} from '../color.js';\nimport {assert} from '../asserts.js';\nimport {extend} from '../array.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  readBoolean,\n  readDecimal,\n  readString,\n  writeBooleanTextNode,\n  writeCDATASection,\n  writeDecimalTextNode,\n  writeStringTextNode,\n} from './xsd.js';\nimport {toRadians} from '../math.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {Object} Vec2\n * @property {number} x X coordinate.\n * @property {import(\"../style/Icon.js\").IconAnchorUnits} xunits Units of x.\n * @property {number} y Y coordinate.\n * @property {import(\"../style/Icon.js\").IconAnchorUnits} yunits Units of Y.\n * @property {import(\"../style/Icon.js\").IconOrigin} [origin] Origin.\n */\n\n/**\n * @typedef {Object} GxTrackObject\n * @property {Array<Array<number>>} coordinates Coordinates.\n * @property {Array<number>} whens Whens.\n */\n\n/**\n * @const\n * @type {Array<string>}\n */\nconst GX_NAMESPACE_URIS = ['http://www.google.com/kml/ext/2.2'];\n\n/**\n * @const\n * @type {Array<null|string>}\n */\nconst NAMESPACE_URIS = [\n  null,\n  'http://earth.google.com/kml/2.0',\n  'http://earth.google.com/kml/2.1',\n  'http://earth.google.com/kml/2.2',\n  'http://www.opengis.net/kml/2.2',\n];\n\n/**\n * @const\n * @type {string}\n */\nconst SCHEMA_LOCATION =\n  'http://www.opengis.net/kml/2.2 ' +\n  'https://developers.google.com/kml/schema/kml22gx.xsd';\n\n/**\n * @type {Object<string, import(\"../style/Icon.js\").IconAnchorUnits>}\n */\nconst ICON_ANCHOR_UNITS_MAP = {\n  'fraction': 'fraction',\n  'pixels': 'pixels',\n  'insetPixels': 'pixels',\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PLACEMARK_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'ExtendedData': extendedDataParser,\n    'Region': regionParser,\n    'MultiGeometry': makeObjectPropertySetter(readMultiGeometry, 'geometry'),\n    'LineString': makeObjectPropertySetter(readLineString, 'geometry'),\n    'LinearRing': makeObjectPropertySetter(readLinearRing, 'geometry'),\n    'Point': makeObjectPropertySetter(readPoint, 'geometry'),\n    'Polygon': makeObjectPropertySetter(readPolygon, 'geometry'),\n    'Style': makeObjectPropertySetter(readStyle),\n    'StyleMap': placemarkStyleMapParser,\n    'address': makeObjectPropertySetter(readString),\n    'description': makeObjectPropertySetter(readString),\n    'name': makeObjectPropertySetter(readString),\n    'open': makeObjectPropertySetter(readBoolean),\n    'phoneNumber': makeObjectPropertySetter(readString),\n    'styleUrl': makeObjectPropertySetter(readStyleURL),\n    'visibility': makeObjectPropertySetter(readBoolean),\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'MultiTrack': makeObjectPropertySetter(readGxMultiTrack, 'geometry'),\n    'Track': makeObjectPropertySetter(readGxTrack, 'geometry'),\n  })\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst NETWORK_LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ExtendedData': extendedDataParser,\n  'Region': regionParser,\n  'Link': linkParser,\n  'address': makeObjectPropertySetter(readString),\n  'description': makeObjectPropertySetter(readString),\n  'name': makeObjectPropertySetter(readString),\n  'open': makeObjectPropertySetter(readBoolean),\n  'phoneNumber': makeObjectPropertySetter(readString),\n  'visibility': makeObjectPropertySetter(readBoolean),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'href': makeObjectPropertySetter(readURI),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst REGION_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LatLonAltBox': latLonAltBoxParser,\n  'Lod': lodParser,\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst KML_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['Document', 'Placemark']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst KML_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Document': makeChildAppender(writeDocument),\n  'Placemark': makeChildAppender(writePlacemark),\n});\n\n/**\n * @type {import(\"../color.js\").Color}\n */\nlet DEFAULT_COLOR;\n\n/**\n * @type {Fill|null}\n */\nlet DEFAULT_FILL_STYLE = null;\n\n/**\n * Get the default fill style (or null if not yet set).\n * @return {Fill|null} The default fill style.\n */\nexport function getDefaultFillStyle() {\n  return DEFAULT_FILL_STYLE;\n}\n\n/**\n * @type {import(\"../size.js\").Size}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR;\n\n/**\n * @type {import(\"../style/Icon.js\").IconAnchorUnits}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n\n/**\n * @type {import(\"../style/Icon.js\").IconAnchorUnits}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n\n/**\n * @type {import(\"../size.js\").Size}\n */\nlet DEFAULT_IMAGE_STYLE_SIZE;\n\n/**\n * @type {string}\n */\nlet DEFAULT_IMAGE_STYLE_SRC;\n\n/**\n * @type {import(\"../style/Image.js\").default|null}\n */\nlet DEFAULT_IMAGE_STYLE = null;\n\n/**\n * Get the default image style (or null if not yet set).\n * @return {import(\"../style/Image.js\").default|null} The default image style.\n */\nexport function getDefaultImageStyle() {\n  return DEFAULT_IMAGE_STYLE;\n}\n\n/**\n * @type {string}\n */\nlet DEFAULT_NO_IMAGE_STYLE;\n\n/**\n * @type {Stroke|null}\n */\nlet DEFAULT_STROKE_STYLE = null;\n\n/**\n * Get the default stroke style (or null if not yet set).\n * @return {Stroke|null} The default stroke style.\n */\nexport function getDefaultStrokeStyle() {\n  return DEFAULT_STROKE_STYLE;\n}\n\n/**\n * @type {Stroke}\n */\nlet DEFAULT_TEXT_STROKE_STYLE;\n\n/**\n * @type {Text|null}\n */\nlet DEFAULT_TEXT_STYLE = null;\n\n/**\n * Get the default text style (or null if not yet set).\n * @return {Text|null} The default text style.\n */\nexport function getDefaultTextStyle() {\n  return DEFAULT_TEXT_STYLE;\n}\n\n/**\n * @type {Style|null}\n */\nlet DEFAULT_STYLE = null;\n\n/**\n * Get the default style (or null if not yet set).\n * @return {Style|null} The default style.\n */\nexport function getDefaultStyle() {\n  return DEFAULT_STYLE;\n}\n\n/**\n * @type {Array<Style>|null}\n */\nlet DEFAULT_STYLE_ARRAY = null;\n\n/**\n * Get the default style array (or null if not yet set).\n * @return {Array<Style>|null} The default style.\n */\nexport function getDefaultStyleArray() {\n  return DEFAULT_STYLE_ARRAY;\n}\n\n/**\n * Function that returns the scale needed to normalize an icon image to 32 pixels.\n * @param {import(\"../size.js\").Size} size Image size.\n * @return {number} Scale.\n */\nfunction scaleForSize(size) {\n  return 32 / Math.min(size[0], size[1]);\n}\n\nfunction createStyleDefaults() {\n  DEFAULT_COLOR = [255, 255, 255, 1];\n\n  DEFAULT_FILL_STYLE = new Fill({\n    color: DEFAULT_COLOR,\n  });\n\n  DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];\n\n  DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = 'pixels';\n\n  DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = 'pixels';\n\n  DEFAULT_IMAGE_STYLE_SIZE = [64, 64];\n\n  DEFAULT_IMAGE_STYLE_SRC =\n    'https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png';\n\n  DEFAULT_IMAGE_STYLE = new Icon({\n    anchor: DEFAULT_IMAGE_STYLE_ANCHOR,\n    anchorOrigin: 'bottom-left',\n    anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,\n    anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,\n    crossOrigin: 'anonymous',\n    rotation: 0,\n    scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),\n    size: DEFAULT_IMAGE_STYLE_SIZE,\n    src: DEFAULT_IMAGE_STYLE_SRC,\n  });\n\n  DEFAULT_NO_IMAGE_STYLE = 'NO_IMAGE';\n\n  DEFAULT_STROKE_STYLE = new Stroke({\n    color: DEFAULT_COLOR,\n    width: 1,\n  });\n\n  DEFAULT_TEXT_STROKE_STYLE = new Stroke({\n    color: [51, 51, 51, 1],\n    width: 2,\n  });\n\n  DEFAULT_TEXT_STYLE = new Text({\n    font: 'bold 16px Helvetica',\n    fill: DEFAULT_FILL_STYLE,\n    stroke: DEFAULT_TEXT_STROKE_STYLE,\n    scale: 0.8,\n  });\n\n  DEFAULT_STYLE = new Style({\n    fill: DEFAULT_FILL_STYLE,\n    image: DEFAULT_IMAGE_STYLE,\n    text: DEFAULT_TEXT_STYLE,\n    stroke: DEFAULT_STROKE_STYLE,\n    zIndex: 0,\n  });\n\n  DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];\n}\n\n/**\n * @type {HTMLTextAreaElement}\n */\nlet TEXTAREA;\n\n/**\n * A function that takes a url `{string}` and returns a url `{string}`.\n * Might be used to change an icon path or to substitute a\n * data url obtained from a KMZ array buffer.\n *\n * @typedef {function(string):string} IconUrlFunction\n * @api\n */\n\n/**\n * Function that returns a url unchanged.\n * @param {string} href Input url.\n * @return {string} Output url.\n */\nfunction defaultIconUrlFunction(href) {\n  return href;\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [extractStyles=true] Extract styles from the KML.\n * @property {boolean} [showPointNames=true] Show names as labels for placemarks which contain points.\n * @property {Array<Style>} [defaultStyle] Default style. The\n * default default style is the same as Google Earth.\n * @property {boolean} [writeStyles=true] Write styles into KML.\n * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images. Note that you must provide a\n * `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * @property {IconUrlFunction} [iconUrlFunction] Function that takes a url string and returns a url string.\n * Might be used to change an icon path or to substitute a data url obtained from a KMZ array buffer.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the KML format.\n *\n * {@link module:ol/format/KML~KML#readFeature} will read the first feature from\n * a KML source.\n *\n * MultiGeometries are converted into GeometryCollections if they are a mix of\n * geometry types, and into MultiPoint/MultiLineString/MultiPolygon if they are\n * all of the same type.\n *\n * @api\n */\nclass KML extends XMLFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    if (!DEFAULT_STYLE_ARRAY) {\n      createStyleDefaults();\n    }\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {Array<Style>}\n     */\n    this.defaultStyle_ = options.defaultStyle\n      ? options.defaultStyle\n      : DEFAULT_STYLE_ARRAY;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.extractStyles_ =\n      options.extractStyles !== undefined ? options.extractStyles : true;\n\n    /**\n     * @type {boolean}\n     */\n    this.writeStyles_ =\n      options.writeStyles !== undefined ? options.writeStyles : true;\n\n    /**\n     * @private\n     * @type {!Object<string, (Array<Style>|string)>}\n     */\n    this.sharedStyles_ = {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.showPointNames_ =\n      options.showPointNames !== undefined ? options.showPointNames : true;\n\n    /**\n     * @type {null|string}\n     */\n    this.crossOrigin_ =\n      options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';\n\n    /**\n     * @type {IconUrlFunction}\n     */\n    this.iconUrlFunction_ = options.iconUrlFunction\n      ? options.iconUrlFunction\n      : defaultIconUrlFunction;\n\n    this.supportedMediaTypes = ['application/vnd.google-earth.kml+xml'];\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<Feature>|undefined} Features.\n   */\n  readDocumentOrFolder_(node, objectStack) {\n    // FIXME use scope somehow\n    const parsersNS = makeStructureNS(NAMESPACE_URIS, {\n      'Document': makeArrayExtender(this.readDocumentOrFolder_, this),\n      'Folder': makeArrayExtender(this.readDocumentOrFolder_, this),\n      'Placemark': makeArrayPusher(this.readPlacemark_, this),\n      'Style': this.readSharedStyle_.bind(this),\n      'StyleMap': this.readSharedStyleMap_.bind(this),\n    });\n    /** @type {Array<Feature>} */\n    // @ts-ignore\n    const features = pushParseAndPop([], parsersNS, node, objectStack, this);\n    if (features) {\n      return features;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Feature|undefined} Feature.\n   */\n  readPlacemark_(node, objectStack) {\n    const object = pushParseAndPop(\n      {'geometry': null},\n      PLACEMARK_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (!object) {\n      return undefined;\n    }\n    const feature = new Feature();\n    const id = node.getAttribute('id');\n    if (id !== null) {\n      feature.setId(id);\n    }\n    const options = /** @type {import(\"./Feature.js\").ReadOptions} */ (\n      objectStack[0]\n    );\n\n    const geometry = object['geometry'];\n    if (geometry) {\n      transformGeometryWithOptions(geometry, false, options);\n    }\n    feature.setGeometry(geometry);\n    delete object['geometry'];\n\n    if (this.extractStyles_) {\n      const style = object['Style'];\n      const styleUrl = object['styleUrl'];\n      const styleFunction = createFeatureStyleFunction(\n        style,\n        styleUrl,\n        this.defaultStyle_,\n        this.sharedStyles_,\n        this.showPointNames_\n      );\n      feature.setStyle(styleFunction);\n    }\n    delete object['Style'];\n    // we do not remove the styleUrl property from the object, so it\n    // gets stored on feature when setProperties is called\n\n    feature.setProperties(object, true);\n\n    return feature;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  readSharedStyle_(node, objectStack) {\n    const id = node.getAttribute('id');\n    if (id !== null) {\n      const style = readStyle.call(this, node, objectStack);\n      if (style) {\n        let styleUri;\n        let baseURI = node.baseURI;\n        if (!baseURI || baseURI == 'about:blank') {\n          baseURI = window.location.href;\n        }\n        if (baseURI) {\n          const url = new URL('#' + id, baseURI);\n          styleUri = url.href;\n        } else {\n          styleUri = '#' + id;\n        }\n        this.sharedStyles_[styleUri] = style;\n      }\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  readSharedStyleMap_(node, objectStack) {\n    const id = node.getAttribute('id');\n    if (id === null) {\n      return;\n    }\n    const styleMapValue = readStyleMapValue.call(this, node, objectStack);\n    if (!styleMapValue) {\n      return;\n    }\n    let styleUri;\n    let baseURI = node.baseURI;\n    if (!baseURI || baseURI == 'about:blank') {\n      baseURI = window.location.href;\n    }\n    if (baseURI) {\n      const url = new URL('#' + id, baseURI);\n      styleUri = url.href;\n    } else {\n      styleUri = '#' + id;\n    }\n    this.sharedStyles_[styleUri] = styleMapValue;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, options) {\n    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {\n      return null;\n    }\n    const feature = this.readPlacemark_(node, [\n      this.getReadOptions(node, options),\n    ]);\n    if (feature) {\n      return feature;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {\n      return [];\n    }\n    let features;\n    const localName = node.localName;\n    if (localName == 'Document' || localName == 'Folder') {\n      features = this.readDocumentOrFolder_(node, [\n        this.getReadOptions(node, options),\n      ]);\n      if (features) {\n        return features;\n      } else {\n        return [];\n      }\n    } else if (localName == 'Placemark') {\n      const feature = this.readPlacemark_(node, [\n        this.getReadOptions(node, options),\n      ]);\n      if (feature) {\n        return [feature];\n      } else {\n        return [];\n      }\n    } else if (localName == 'kml') {\n      features = [];\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        const fs = this.readFeaturesFromNode(n, options);\n        if (fs) {\n          extend(features, fs);\n        }\n      }\n      return features;\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * Read the name of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {string|undefined} Name.\n   * @api\n   */\n  readName(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readNameFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readNameFromDocument(/** @type {Document} */ (source));\n    } else {\n      return this.readNameFromNode(/** @type {Element} */ (source));\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {string|undefined} Name.\n   */\n  readNameFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        const name = this.readNameFromNode(/** @type {Element} */ (n));\n        if (name) {\n          return name;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {string|undefined} Name.\n   */\n  readNameFromNode(node) {\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'name') {\n        return readString(n);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        (localName == 'Document' ||\n          localName == 'Folder' ||\n          localName == 'Placemark' ||\n          localName == 'kml')\n      ) {\n        const name = this.readNameFromNode(n);\n        if (name) {\n          return name;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Read the network links of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {Array<Object>} Network links.\n   * @api\n   */\n  readNetworkLinks(source) {\n    const networkLinks = [];\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      extend(networkLinks, this.readNetworkLinksFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend(\n        networkLinks,\n        this.readNetworkLinksFromDocument(/** @type {Document} */ (source))\n      );\n    } else {\n      extend(\n        networkLinks,\n        this.readNetworkLinksFromNode(/** @type {Element} */ (source))\n      );\n    }\n    return networkLinks;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Array<Object>} Network links.\n   */\n  readNetworkLinksFromDocument(doc) {\n    const networkLinks = [];\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(\n          networkLinks,\n          this.readNetworkLinksFromNode(/** @type {Element} */ (n))\n        );\n      }\n    }\n    return networkLinks;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Array<Object>} Network links.\n   */\n  readNetworkLinksFromNode(node) {\n    const networkLinks = [];\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        n.localName == 'NetworkLink'\n      ) {\n        const obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n, []);\n        networkLinks.push(obj);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        (localName == 'Document' || localName == 'Folder' || localName == 'kml')\n      ) {\n        extend(networkLinks, this.readNetworkLinksFromNode(n));\n      }\n    }\n    return networkLinks;\n  }\n\n  /**\n   * Read the regions of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {Array<Object>} Regions.\n   * @api\n   */\n  readRegion(source) {\n    const regions = [];\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      extend(regions, this.readRegionFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend(\n        regions,\n        this.readRegionFromDocument(/** @type {Document} */ (source))\n      );\n    } else {\n      extend(regions, this.readRegionFromNode(/** @type {Element} */ (source)));\n    }\n    return regions;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Array<Object>} Region.\n   */\n  readRegionFromDocument(doc) {\n    const regions = [];\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(regions, this.readRegionFromNode(/** @type {Element} */ (n)));\n      }\n    }\n    return regions;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Array<Object>} Region.\n   * @api\n   */\n  readRegionFromNode(node) {\n    const regions = [];\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'Region') {\n        const obj = pushParseAndPop({}, REGION_PARSERS, n, []);\n        regions.push(obj);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        (localName == 'Document' || localName == 'Folder' || localName == 'kml')\n      ) {\n        extend(regions, this.readRegionFromNode(n));\n      }\n    }\n    return regions;\n  }\n\n  /**\n   * Encode an array of features in the KML format as an XML node. GeometryCollections,\n   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.\n   *\n   * @param {Array<Feature>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   * @api\n   */\n  writeFeaturesNode(features, options) {\n    options = this.adaptOptions(options);\n    const kml = createElementNS(NAMESPACE_URIS[4], 'kml');\n    const xmlnsUri = 'http://www.w3.org/2000/xmlns/';\n    kml.setAttributeNS(xmlnsUri, 'xmlns:gx', GX_NAMESPACE_URIS[0]);\n    kml.setAttributeNS(xmlnsUri, 'xmlns:xsi', XML_SCHEMA_INSTANCE_URI);\n    kml.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      SCHEMA_LOCATION\n    );\n\n    const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {\n        node: kml,\n      };\n    /** @type {!Object<string, (Array<Feature>|Feature|undefined)>} */\n    const properties = {};\n    if (features.length > 1) {\n      properties['Document'] = features;\n    } else if (features.length == 1) {\n      properties['Placemark'] = features[0];\n    }\n    const orderedKeys = KML_SEQUENCE[kml.namespaceURI];\n    const values = makeSequence(properties, orderedKeys);\n    pushSerializeAndPop(\n      context,\n      KML_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      [options],\n      orderedKeys,\n      this\n    );\n    return kml;\n  }\n}\n\n/**\n * @param {Style|undefined} foundStyle Style.\n * @param {string} name Name.\n * @return {Style} style Style.\n */\nfunction createNameStyleFunction(foundStyle, name) {\n  const textOffset = [0, 0];\n  /** @type {CanvasTextAlign} */\n  let textAlign = 'start';\n  const imageStyle = foundStyle.getImage();\n  if (imageStyle) {\n    const imageSize = imageStyle.getSize();\n    if (imageSize && imageSize.length == 2) {\n      const imageScale = imageStyle.getScaleArray();\n      const anchor = imageStyle.getAnchor();\n      // Offset the label to be centered to the right of the icon,\n      // if there is one.\n      textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);\n      textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);\n      textAlign = 'left';\n    }\n  }\n  let textStyle = foundStyle.getText();\n  if (textStyle) {\n    // clone the text style, customizing it with name, alignments and offset.\n    // Note that kml does not support many text options that OpenLayers does (rotation, textBaseline).\n    textStyle = textStyle.clone();\n    textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());\n    textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());\n    textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());\n    textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);\n  } else {\n    textStyle = DEFAULT_TEXT_STYLE.clone();\n  }\n  textStyle.setText(name);\n  textStyle.setOffsetX(textOffset[0]);\n  textStyle.setOffsetY(textOffset[1]);\n  textStyle.setTextAlign(textAlign);\n\n  const nameStyle = new Style({\n    image: imageStyle,\n    text: textStyle,\n  });\n  return nameStyle;\n}\n\n/**\n * @param {Array<Style>|undefined} style Style.\n * @param {string} styleUrl Style URL.\n * @param {Array<Style>} defaultStyle Default style.\n * @param {!Object<string, (Array<Style>|string)>} sharedStyles Shared styles.\n * @param {boolean|undefined} showPointNames true to show names for point placemarks.\n * @return {import(\"../style/Style.js\").StyleFunction} Feature style function.\n */\nfunction createFeatureStyleFunction(\n  style,\n  styleUrl,\n  defaultStyle,\n  sharedStyles,\n  showPointNames\n) {\n  return (\n    /**\n     * @param {Feature} feature feature.\n     * @param {number} resolution Resolution.\n     * @return {Array<Style>|Style} Style.\n     */\n    function (feature, resolution) {\n      let drawName = showPointNames;\n      let name = '';\n      let multiGeometryPoints = [];\n      if (drawName) {\n        const geometry = feature.getGeometry();\n        if (geometry) {\n          if (geometry instanceof GeometryCollection) {\n            multiGeometryPoints = geometry\n              .getGeometriesArrayRecursive()\n              .filter(function (geometry) {\n                const type = geometry.getType();\n                return type === 'Point' || type === 'MultiPoint';\n              });\n            drawName = multiGeometryPoints.length > 0;\n          } else {\n            const type = geometry.getType();\n            drawName = type === 'Point' || type === 'MultiPoint';\n          }\n        }\n      }\n\n      if (drawName) {\n        name = /** @type {string} */ (feature.get('name'));\n        drawName = drawName && !!name;\n        // convert any html character codes\n        if (drawName && /&[^&]+;/.test(name)) {\n          if (!TEXTAREA) {\n            TEXTAREA = document.createElement('textarea');\n          }\n          TEXTAREA.innerHTML = name;\n          name = TEXTAREA.value;\n        }\n      }\n\n      let featureStyle = defaultStyle;\n      if (style) {\n        featureStyle = style;\n      } else if (styleUrl) {\n        featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);\n      }\n      if (drawName) {\n        const nameStyle = createNameStyleFunction(featureStyle[0], name);\n        if (multiGeometryPoints.length > 0) {\n          // in multigeometries restrict the name style to points and create a\n          // style without image or text for geometries requiring fill or stroke\n          // including any polygon specific style if there is one\n          nameStyle.setGeometry(new GeometryCollection(multiGeometryPoints));\n          const baseStyle = new Style({\n            geometry: featureStyle[0].getGeometry(),\n            image: null,\n            fill: featureStyle[0].getFill(),\n            stroke: featureStyle[0].getStroke(),\n            text: null,\n          });\n          return [nameStyle, baseStyle].concat(featureStyle.slice(1));\n        }\n        return nameStyle;\n      }\n      return featureStyle;\n    }\n  );\n}\n\n/**\n * @param {Array<Style>|string|undefined} styleValue Style value.\n * @param {Array<Style>} defaultStyle Default style.\n * @param {!Object<string, (Array<Style>|string)>} sharedStyles\n * Shared styles.\n * @return {Array<Style>} Style.\n */\nfunction findStyle(styleValue, defaultStyle, sharedStyles) {\n  if (Array.isArray(styleValue)) {\n    return styleValue;\n  } else if (typeof styleValue === 'string') {\n    return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);\n  } else {\n    return defaultStyle;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {import(\"../color.js\").Color|undefined} Color.\n */\nfunction readColor(node) {\n  const s = getAllTextContent(node, false);\n  // The KML specification states that colors should not include a leading `#`\n  // but we tolerate them.\n  const m = /^\\s*#?\\s*([0-9A-Fa-f]{8})\\s*$/.exec(s);\n  if (m) {\n    const hexColor = m[1];\n    return [\n      parseInt(hexColor.substr(6, 2), 16),\n      parseInt(hexColor.substr(4, 2), 16),\n      parseInt(hexColor.substr(2, 2), 16),\n      parseInt(hexColor.substr(0, 2), 16) / 255,\n    ];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {Array<number>|undefined} Flat coordinates.\n */\nexport function readFlatCoordinates(node) {\n  let s = getAllTextContent(node, false);\n  const flatCoordinates = [];\n  // The KML specification states that coordinate tuples should not include\n  // spaces, but we tolerate them.\n  s = s.replace(/\\s*,\\s*/g, ',');\n  const re =\n    /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?),([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|,|$)(?:([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|$))?\\s*/i;\n  let m;\n  while ((m = re.exec(s))) {\n    const x = parseFloat(m[1]);\n    const y = parseFloat(m[2]);\n    const z = m[3] ? parseFloat(m[3]) : 0;\n    flatCoordinates.push(x, y, z);\n    s = s.substr(m[0].length);\n  }\n  if (s !== '') {\n    return undefined;\n  }\n  return flatCoordinates;\n}\n\n/**\n * @param {Node} node Node.\n * @return {string} URI.\n */\nfunction readURI(node) {\n  const s = getAllTextContent(node, false).trim();\n  let baseURI = node.baseURI;\n  if (!baseURI || baseURI == 'about:blank') {\n    baseURI = window.location.href;\n  }\n  if (baseURI) {\n    const url = new URL(s, baseURI);\n    return url.href;\n  } else {\n    return s;\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @return {string} URI.\n */\nfunction readStyleURL(node) {\n  // KML files in the wild occasionally forget the leading\n  // `#` on styleUrlsdefined in the same document.\n  const s = getAllTextContent(node, false)\n    .trim()\n    .replace(/^(?!.*#)/, '#');\n  let baseURI = node.baseURI;\n  if (!baseURI || baseURI == 'about:blank') {\n    baseURI = window.location.href;\n  }\n  if (baseURI) {\n    const url = new URL(s, baseURI);\n    return url.href;\n  } else {\n    return s;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @return {Vec2} Vec2.\n */\nfunction readVec2(node) {\n  const xunits = node.getAttribute('xunits');\n  const yunits = node.getAttribute('yunits');\n  /** @type {import('../style/Icon.js').IconOrigin} */\n  let origin;\n  if (xunits !== 'insetPixels') {\n    if (yunits !== 'insetPixels') {\n      origin = 'bottom-left';\n    } else {\n      origin = 'top-left';\n    }\n  } else {\n    if (yunits !== 'insetPixels') {\n      origin = 'bottom-right';\n    } else {\n      origin = 'top-right';\n    }\n  }\n  return {\n    x: parseFloat(node.getAttribute('x')),\n    xunits: ICON_ANCHOR_UNITS_MAP[xunits],\n    y: parseFloat(node.getAttribute('y')),\n    yunits: ICON_ANCHOR_UNITS_MAP[yunits],\n    origin: origin,\n  };\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Scale.\n */\nfunction readScale(node) {\n  return readDecimal(node);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst STYLE_MAP_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Pair': pairDataParser,\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<Style>|string|undefined} StyleMap.\n */\nfunction readStyleMapValue(node, objectStack) {\n  return pushParseAndPop(undefined, STYLE_MAP_PARSERS, node, objectStack, this);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ICON_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Icon': makeObjectPropertySetter(readIcon),\n  'color': makeObjectPropertySetter(readColor),\n  'heading': makeObjectPropertySetter(readDecimal),\n  'hotSpot': makeObjectPropertySetter(readVec2),\n  'scale': makeObjectPropertySetter(readScale),\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction iconStyleParser(node, objectStack) {\n  // FIXME refreshMode\n  // FIXME refreshInterval\n  // FIXME viewRefreshTime\n  // FIXME viewBoundScale\n  // FIXME viewFormat\n  // FIXME httpQuery\n  const object = pushParseAndPop({}, ICON_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = /** @type {Object} */ (\n    objectStack[objectStack.length - 1]\n  );\n  const IconObject = 'Icon' in object ? object['Icon'] : {};\n  const drawIcon = !('Icon' in object) || Object.keys(IconObject).length > 0;\n  let src;\n  const href = /** @type {string|undefined} */ (IconObject['href']);\n  if (href) {\n    src = href;\n  } else if (drawIcon) {\n    src = DEFAULT_IMAGE_STYLE_SRC;\n  }\n  let anchor, anchorXUnits, anchorYUnits;\n  /** @type {import('../style/Icon.js').IconOrigin|undefined} */\n  let anchorOrigin = 'bottom-left';\n  const hotSpot = /** @type {Vec2|undefined} */ (object['hotSpot']);\n  if (hotSpot) {\n    anchor = [hotSpot.x, hotSpot.y];\n    anchorXUnits = hotSpot.xunits;\n    anchorYUnits = hotSpot.yunits;\n    anchorOrigin = hotSpot.origin;\n  } else if (/^https?:\\/\\/maps\\.(?:google|gstatic)\\.com\\//.test(src)) {\n    // Google hotspots from https://kml4earth.appspot.com/icons.html#notes\n    if (src.includes('pushpin')) {\n      anchor = DEFAULT_IMAGE_STYLE_ANCHOR;\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    } else if (src.includes('arrow-reverse')) {\n      anchor = [54, 42];\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    } else if (src.includes('paddle')) {\n      anchor = [32, 1];\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    }\n  }\n\n  let offset;\n  const x = /** @type {number|undefined} */ (IconObject['x']);\n  const y = /** @type {number|undefined} */ (IconObject['y']);\n  if (x !== undefined && y !== undefined) {\n    offset = [x, y];\n  }\n\n  let size;\n  const w = /** @type {number|undefined} */ (IconObject['w']);\n  const h = /** @type {number|undefined} */ (IconObject['h']);\n  if (w !== undefined && h !== undefined) {\n    size = [w, h];\n  }\n\n  let rotation;\n  const heading = /** @type {number} */ (object['heading']);\n  if (heading !== undefined) {\n    rotation = toRadians(heading);\n  }\n\n  const scale = /** @type {number|undefined} */ (object['scale']);\n\n  const color = /** @type {Array<number>|undefined} */ (object['color']);\n\n  if (drawIcon) {\n    if (src == DEFAULT_IMAGE_STYLE_SRC) {\n      size = DEFAULT_IMAGE_STYLE_SIZE;\n    }\n\n    const imageStyle = new Icon({\n      anchor: anchor,\n      anchorOrigin: anchorOrigin,\n      anchorXUnits: anchorXUnits,\n      anchorYUnits: anchorYUnits,\n      crossOrigin: this.crossOrigin_,\n      offset: offset,\n      offsetOrigin: 'bottom-left',\n      rotation: rotation,\n      scale: scale,\n      size: size,\n      src: this.iconUrlFunction_(src),\n      color: color,\n    });\n\n    const imageScale = imageStyle.getScaleArray()[0];\n    const imageSize = imageStyle.getSize();\n    if (imageSize === null) {\n      const imageState = imageStyle.getImageState();\n      if (imageState === ImageState.IDLE || imageState === ImageState.LOADING) {\n        const listener = function () {\n          const imageState = imageStyle.getImageState();\n          if (\n            !(\n              imageState === ImageState.IDLE ||\n              imageState === ImageState.LOADING\n            )\n          ) {\n            const imageSize = imageStyle.getSize();\n            if (imageSize && imageSize.length == 2) {\n              const resizeScale = scaleForSize(imageSize);\n              imageStyle.setScale(imageScale * resizeScale);\n            }\n            imageStyle.unlistenImageChange(listener);\n          }\n        };\n        imageStyle.listenImageChange(listener);\n        if (imageState === ImageState.IDLE) {\n          imageStyle.load();\n        }\n      }\n    } else if (imageSize.length == 2) {\n      const resizeScale = scaleForSize(imageSize);\n      imageStyle.setScale(imageScale * resizeScale);\n    }\n    styleObject['imageStyle'] = imageStyle;\n  } else {\n    // handle the case when we explicitly want to draw no icon.\n    styleObject['imageStyle'] = DEFAULT_NO_IMAGE_STYLE;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'scale': makeObjectPropertySetter(readScale),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction labelStyleParser(node, objectStack) {\n  // FIXME colorMode\n  const object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const textStyle = new Text({\n    fill: new Fill({\n      color:\n        /** @type {import(\"../color.js\").Color} */\n        ('color' in object ? object['color'] : DEFAULT_COLOR),\n    }),\n    scale: /** @type {number|undefined} */ (object['scale']),\n  });\n  styleObject['textStyle'] = textStyle;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LINE_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'width': makeObjectPropertySetter(readDecimal),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction lineStyleParser(node, objectStack) {\n  // FIXME colorMode\n  // FIXME gx:outerColor\n  // FIXME gx:outerWidth\n  // FIXME gx:physicalWidth\n  // FIXME gx:labelVisibility\n  const object = pushParseAndPop({}, LINE_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const strokeStyle = new Stroke({\n    color:\n      /** @type {import(\"../color.js\").Color} */\n      ('color' in object ? object['color'] : DEFAULT_COLOR),\n    width: /** @type {number} */ ('width' in object ? object['width'] : 1),\n  });\n  styleObject['strokeStyle'] = strokeStyle;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst POLY_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'fill': makeObjectPropertySetter(readBoolean),\n  'outline': makeObjectPropertySetter(readBoolean),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction polyStyleParser(node, objectStack) {\n  // FIXME colorMode\n  const object = pushParseAndPop({}, POLY_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const fillStyle = new Fill({\n    color:\n      /** @type {import(\"../color.js\").Color} */\n      ('color' in object ? object['color'] : DEFAULT_COLOR),\n  });\n  styleObject['fillStyle'] = fillStyle;\n  const fill = /** @type {boolean|undefined} */ (object['fill']);\n  if (fill !== undefined) {\n    styleObject['fill'] = fill;\n  }\n  const outline = /** @type {boolean|undefined} */ (object['outline']);\n  if (outline !== undefined) {\n    styleObject['outline'] = outline;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst FLAT_LINEAR_RING_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'coordinates': makeReplacer(readFlatCoordinates),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<number>} LinearRing flat coordinates.\n */\nfunction readFlatLinearRing(node, objectStack) {\n  return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction gxCoordParser(node, objectStack) {\n  const gxTrackObject =\n    /** @type {GxTrackObject} */\n    (objectStack[objectStack.length - 1]);\n  const coordinates = gxTrackObject.coordinates;\n  const s = getAllTextContent(node, false);\n  const re =\n    /^\\s*([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s*$/i;\n  const m = re.exec(s);\n  if (m) {\n    const x = parseFloat(m[1]);\n    const y = parseFloat(m[2]);\n    const z = parseFloat(m[3]);\n    coordinates.push([x, y, z]);\n  } else {\n    coordinates.push([]);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {\n  'Track': makeArrayPusher(readGxTrack),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {MultiLineString|undefined} MultiLineString.\n */\nfunction readGxMultiTrack(node, objectStack) {\n  const lineStrings = pushParseAndPop(\n    [],\n    GX_MULTITRACK_GEOMETRY_PARSERS,\n    node,\n    objectStack\n  );\n  if (!lineStrings) {\n    return undefined;\n  }\n  return new MultiLineString(lineStrings);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GX_TRACK_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'when': whenParser,\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'coord': gxCoordParser,\n  })\n);\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {LineString|undefined} LineString.\n */\nfunction readGxTrack(node, objectStack) {\n  const gxTrackObject = pushParseAndPop(\n    /** @type {GxTrackObject} */ ({\n      coordinates: [],\n      whens: [],\n    }),\n    GX_TRACK_PARSERS,\n    node,\n    objectStack\n  );\n  if (!gxTrackObject) {\n    return undefined;\n  }\n  const flatCoordinates = [];\n  const coordinates = gxTrackObject.coordinates;\n  const whens = gxTrackObject.whens;\n  for (\n    let i = 0, ii = Math.min(coordinates.length, whens.length);\n    i < ii;\n    ++i\n  ) {\n    if (coordinates[i].length == 3) {\n      flatCoordinates.push(\n        coordinates[i][0],\n        coordinates[i][1],\n        coordinates[i][2],\n        whens[i]\n      );\n    }\n  }\n  return new LineString(flatCoordinates, 'XYZM');\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ICON_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'href': makeObjectPropertySetter(readURI),\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'x': makeObjectPropertySetter(readDecimal),\n    'y': makeObjectPropertySetter(readDecimal),\n    'w': makeObjectPropertySetter(readDecimal),\n    'h': makeObjectPropertySetter(readDecimal),\n  })\n);\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object} Icon object.\n */\nfunction readIcon(node, objectStack) {\n  const iconObject = pushParseAndPop({}, ICON_PARSERS, node, objectStack);\n  if (iconObject) {\n    return iconObject;\n  } else {\n    return null;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'coordinates': makeReplacer(readFlatCoordinates),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<number>} Flat coordinates.\n */\nfunction readFlatCoordinatesFromNode(node, objectStack) {\n  return pushParseAndPop(\n    null,\n    GEOMETRY_FLAT_COORDINATES_PARSERS,\n    node,\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'extrude': makeObjectPropertySetter(readBoolean),\n  'tessellate': makeObjectPropertySetter(readBoolean),\n  'altitudeMode': makeObjectPropertySetter(readString),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {LineString|undefined} LineString.\n */\nfunction readLineString(node, objectStack) {\n  const properties = pushParseAndPop(\n    {},\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack\n  );\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const lineString = new LineString(flatCoordinates, 'XYZ');\n    lineString.setProperties(properties, true);\n    return lineString;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Polygon|undefined} Polygon.\n */\nfunction readLinearRing(node, objectStack) {\n  const properties = pushParseAndPop(\n    {},\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack\n  );\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const polygon = new Polygon(flatCoordinates, 'XYZ', [\n      flatCoordinates.length,\n    ]);\n    polygon.setProperties(properties, true);\n    return polygon;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst MULTI_GEOMETRY_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LineString': makeArrayPusher(readLineString),\n  'LinearRing': makeArrayPusher(readLinearRing),\n  'MultiGeometry': makeArrayPusher(readMultiGeometry),\n  'Point': makeArrayPusher(readPoint),\n  'Polygon': makeArrayPusher(readPolygon),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readMultiGeometry(node, objectStack) {\n  const geometries = pushParseAndPop(\n    [],\n    MULTI_GEOMETRY_PARSERS,\n    node,\n    objectStack\n  );\n  if (!geometries) {\n    return null;\n  }\n  if (geometries.length === 0) {\n    return new GeometryCollection(geometries);\n  }\n  let multiGeometry;\n  let homogeneous = true;\n  const type = geometries[0].getType();\n  let geometry;\n  for (let i = 1, ii = geometries.length; i < ii; ++i) {\n    geometry = geometries[i];\n    if (geometry.getType() != type) {\n      homogeneous = false;\n      break;\n    }\n  }\n  if (homogeneous) {\n    let layout;\n    let flatCoordinates;\n    if (type == 'Point') {\n      const point = geometries[0];\n      layout = point.getLayout();\n      flatCoordinates = point.getFlatCoordinates();\n      for (let i = 1, ii = geometries.length; i < ii; ++i) {\n        geometry = geometries[i];\n        extend(flatCoordinates, geometry.getFlatCoordinates());\n      }\n      multiGeometry = new MultiPoint(flatCoordinates, layout);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'LineString') {\n      multiGeometry = new MultiLineString(geometries);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'Polygon') {\n      multiGeometry = new MultiPolygon(geometries);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'GeometryCollection') {\n      multiGeometry = new GeometryCollection(geometries);\n    } else {\n      assert(false, 37); // Unknown geometry type found\n    }\n  } else {\n    multiGeometry = new GeometryCollection(geometries);\n  }\n  return /** @type {import(\"../geom/Geometry.js\").default} */ (multiGeometry);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Point|undefined} Point.\n */\nfunction readPoint(node, objectStack) {\n  const properties = pushParseAndPop(\n    {},\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack\n  );\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const point = new Point(flatCoordinates, 'XYZ');\n    point.setProperties(properties, true);\n    return point;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'innerBoundaryIs': innerBoundaryIsParser,\n  'outerBoundaryIs': outerBoundaryIsParser,\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Polygon|undefined} Polygon.\n */\nfunction readPolygon(node, objectStack) {\n  const properties = pushParseAndPop(\n    /** @type {Object<string,*>} */ ({}),\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack\n  );\n  const flatLinearRings = pushParseAndPop(\n    [null],\n    FLAT_LINEAR_RINGS_PARSERS,\n    node,\n    objectStack\n  );\n  if (flatLinearRings && flatLinearRings[0]) {\n    const flatCoordinates = flatLinearRings[0];\n    const ends = [flatCoordinates.length];\n    for (let i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n      extend(flatCoordinates, flatLinearRings[i]);\n      ends.push(flatCoordinates.length);\n    }\n    const polygon = new Polygon(flatCoordinates, 'XYZ', ends);\n    polygon.setProperties(properties, true);\n    return polygon;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'IconStyle': iconStyleParser,\n  'LabelStyle': labelStyleParser,\n  'LineStyle': lineStyleParser,\n  'PolyStyle': polyStyleParser,\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<Style>} Style.\n */\nfunction readStyle(node, objectStack) {\n  const styleObject = pushParseAndPop(\n    {},\n    STYLE_PARSERS,\n    node,\n    objectStack,\n    this\n  );\n  if (!styleObject) {\n    return null;\n  }\n  let fillStyle =\n    /** @type {Fill} */\n    (\n      'fillStyle' in styleObject ? styleObject['fillStyle'] : DEFAULT_FILL_STYLE\n    );\n  const fill = /** @type {boolean|undefined} */ (styleObject['fill']);\n  if (fill !== undefined && !fill) {\n    fillStyle = null;\n  }\n  let imageStyle;\n  if ('imageStyle' in styleObject) {\n    if (styleObject['imageStyle'] != DEFAULT_NO_IMAGE_STYLE) {\n      imageStyle = styleObject['imageStyle'];\n    }\n  } else {\n    imageStyle = DEFAULT_IMAGE_STYLE;\n  }\n  const textStyle =\n    /** @type {Text} */\n    (\n      'textStyle' in styleObject ? styleObject['textStyle'] : DEFAULT_TEXT_STYLE\n    );\n  const strokeStyle =\n    /** @type {Stroke} */\n    (\n      'strokeStyle' in styleObject\n        ? styleObject['strokeStyle']\n        : DEFAULT_STROKE_STYLE\n    );\n  const outline = /** @type {boolean|undefined} */ (styleObject['outline']);\n  if (outline !== undefined && !outline) {\n    // if the polystyle specifies no outline two styles are needed,\n    // one for non-polygon geometries where linestrings require a stroke\n    // and one for polygons where there should be no stroke\n    return [\n      new Style({\n        geometry: function (feature) {\n          const geometry = feature.getGeometry();\n          const type = geometry.getType();\n          if (type === 'GeometryCollection') {\n            const collection =\n              /** @type {import(\"../geom/GeometryCollection\").default} */ (\n                geometry\n              );\n            return new GeometryCollection(\n              collection\n                .getGeometriesArrayRecursive()\n                .filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type !== 'Polygon' && type !== 'MultiPolygon';\n                })\n            );\n          } else if (type !== 'Polygon' && type !== 'MultiPolygon') {\n            return geometry;\n          }\n        },\n        fill: fillStyle,\n        image: imageStyle,\n        stroke: strokeStyle,\n        text: textStyle,\n        zIndex: undefined, // FIXME\n      }),\n      new Style({\n        geometry: function (feature) {\n          const geometry = feature.getGeometry();\n          const type = geometry.getType();\n          if (type === 'GeometryCollection') {\n            const collection =\n              /** @type {import(\"../geom/GeometryCollection\").default} */ (\n                geometry\n              );\n            return new GeometryCollection(\n              collection\n                .getGeometriesArrayRecursive()\n                .filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type === 'Polygon' || type === 'MultiPolygon';\n                })\n            );\n          } else if (type === 'Polygon' || type === 'MultiPolygon') {\n            return geometry;\n          }\n        },\n        fill: fillStyle,\n        stroke: null,\n        zIndex: undefined, // FIXME\n      }),\n    ];\n  }\n  return [\n    new Style({\n      fill: fillStyle,\n      image: imageStyle,\n      stroke: strokeStyle,\n      text: textStyle,\n      zIndex: undefined, // FIXME\n    }),\n  ];\n}\n\n/**\n * Reads an array of geometries and creates arrays for common geometry\n * properties. Then sets them to the multi geometry.\n * @param {MultiPoint|MultiLineString|MultiPolygon} multiGeometry A multi-geometry.\n * @param {Array<import(\"../geom/Geometry.js\").default>} geometries List of geometries.\n */\nfunction setCommonGeometryProperties(multiGeometry, geometries) {\n  const ii = geometries.length;\n  const extrudes = new Array(geometries.length);\n  const tessellates = new Array(geometries.length);\n  const altitudeModes = new Array(geometries.length);\n  let hasExtrude, hasTessellate, hasAltitudeMode;\n  hasExtrude = false;\n  hasTessellate = false;\n  hasAltitudeMode = false;\n  for (let i = 0; i < ii; ++i) {\n    const geometry = geometries[i];\n    extrudes[i] = geometry.get('extrude');\n    tessellates[i] = geometry.get('tessellate');\n    altitudeModes[i] = geometry.get('altitudeMode');\n    hasExtrude = hasExtrude || extrudes[i] !== undefined;\n    hasTessellate = hasTessellate || tessellates[i] !== undefined;\n    hasAltitudeMode = hasAltitudeMode || altitudeModes[i];\n  }\n  if (hasExtrude) {\n    multiGeometry.set('extrude', extrudes);\n  }\n  if (hasTessellate) {\n    multiGeometry.set('tessellate', tessellates);\n  }\n  if (hasAltitudeMode) {\n    multiGeometry.set('altitudeMode', altitudeModes);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'displayName': makeObjectPropertySetter(readString),\n  'value': makeObjectPropertySetter(readString),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction dataParser(node, objectStack) {\n  const name = node.getAttribute('name');\n  parseNode(DATA_PARSERS, node, objectStack);\n  const featureObject = /** @type {Object} */ (\n    objectStack[objectStack.length - 1]\n  );\n  if (name && featureObject.displayName) {\n    featureObject[name] = {\n      value: featureObject.value,\n      displayName: featureObject.displayName,\n      toString: function () {\n        return featureObject.value;\n      },\n    };\n  } else if (name !== null) {\n    featureObject[name] = featureObject.value;\n  } else if (featureObject.displayName !== null) {\n    featureObject[featureObject.displayName] = featureObject.value;\n  }\n  delete featureObject['value'];\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst EXTENDED_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Data': dataParser,\n  'SchemaData': schemaDataParser,\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction extendedDataParser(node, objectStack) {\n  parseNode(EXTENDED_DATA_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction regionParser(node, objectStack) {\n  parseNode(REGION_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PAIR_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Style': makeObjectPropertySetter(readStyle),\n  'key': makeObjectPropertySetter(readString),\n  'styleUrl': makeObjectPropertySetter(readStyleURL),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction pairDataParser(node, objectStack) {\n  const pairObject = pushParseAndPop({}, PAIR_PARSERS, node, objectStack, this);\n  if (!pairObject) {\n    return;\n  }\n  const key = /** @type {string|undefined} */ (pairObject['key']);\n  if (key && key == 'normal') {\n    const styleUrl = /** @type {string|undefined} */ (pairObject['styleUrl']);\n    if (styleUrl) {\n      objectStack[objectStack.length - 1] = styleUrl;\n    }\n    const style = /** @type {Style} */ (pairObject['Style']);\n    if (style) {\n      objectStack[objectStack.length - 1] = style;\n    }\n  }\n}\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction placemarkStyleMapParser(node, objectStack) {\n  const styleMapValue = readStyleMapValue.call(this, node, objectStack);\n  if (!styleMapValue) {\n    return;\n  }\n  const placemarkObject = objectStack[objectStack.length - 1];\n  if (Array.isArray(styleMapValue)) {\n    placemarkObject['Style'] = styleMapValue;\n  } else if (typeof styleMapValue === 'string') {\n    placemarkObject['styleUrl'] = styleMapValue;\n  } else {\n    assert(false, 38); // `styleMapValue` has an unknown type\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst SCHEMA_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'SimpleData': simpleDataParser,\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction schemaDataParser(node, objectStack) {\n  parseNode(SCHEMA_DATA_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction simpleDataParser(node, objectStack) {\n  const name = node.getAttribute('name');\n  if (name !== null) {\n    const data = readString(node);\n    const featureObject = /** @type {Object} */ (\n      objectStack[objectStack.length - 1]\n    );\n    featureObject[name] = data;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LAT_LON_ALT_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'altitudeMode': makeObjectPropertySetter(readString),\n  'minAltitude': makeObjectPropertySetter(readDecimal),\n  'maxAltitude': makeObjectPropertySetter(readDecimal),\n  'north': makeObjectPropertySetter(readDecimal),\n  'south': makeObjectPropertySetter(readDecimal),\n  'east': makeObjectPropertySetter(readDecimal),\n  'west': makeObjectPropertySetter(readDecimal),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction latLonAltBoxParser(node, objectStack) {\n  const object = pushParseAndPop(\n    {},\n    LAT_LON_ALT_BOX_PARSERS,\n    node,\n    objectStack\n  );\n  if (!object) {\n    return;\n  }\n  const regionObject = /** @type {Object} */ (\n    objectStack[objectStack.length - 1]\n  );\n  const extent = [\n    parseFloat(object['west']),\n    parseFloat(object['south']),\n    parseFloat(object['east']),\n    parseFloat(object['north']),\n  ];\n  regionObject['extent'] = extent;\n  regionObject['altitudeMode'] = object['altitudeMode'];\n  regionObject['minAltitude'] = parseFloat(object['minAltitude']);\n  regionObject['maxAltitude'] = parseFloat(object['maxAltitude']);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LOD_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'minLodPixels': makeObjectPropertySetter(readDecimal),\n  'maxLodPixels': makeObjectPropertySetter(readDecimal),\n  'minFadeExtent': makeObjectPropertySetter(readDecimal),\n  'maxFadeExtent': makeObjectPropertySetter(readDecimal),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction lodParser(node, objectStack) {\n  const object = pushParseAndPop({}, LOD_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const lodObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  lodObject['minLodPixels'] = parseFloat(object['minLodPixels']);\n  lodObject['maxLodPixels'] = parseFloat(object['maxLodPixels']);\n  lodObject['minFadeExtent'] = parseFloat(object['minFadeExtent']);\n  lodObject['maxFadeExtent'] = parseFloat(object['maxFadeExtent']);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst INNER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth\n  // allows multiple, so we parse multiple here too.\n  'LinearRing': makeArrayPusher(readFlatLinearRing),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction innerBoundaryIsParser(node, objectStack) {\n  const innerBoundaryFlatLinearRings = pushParseAndPop(\n    /** @type {Array<Array<number>>} */ ([]),\n    INNER_BOUNDARY_IS_PARSERS,\n    node,\n    objectStack\n  );\n  if (innerBoundaryFlatLinearRings.length > 0) {\n    const flatLinearRings =\n      /** @type {Array<Array<number>>} */\n      (objectStack[objectStack.length - 1]);\n    flatLinearRings.push(...innerBoundaryFlatLinearRings);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LinearRing': makeReplacer(readFlatLinearRing),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction outerBoundaryIsParser(node, objectStack) {\n  /** @type {Array<number>|undefined} */\n  const flatLinearRing = pushParseAndPop(\n    undefined,\n    OUTER_BOUNDARY_IS_PARSERS,\n    node,\n    objectStack\n  );\n  if (flatLinearRing) {\n    const flatLinearRings =\n      /** @type {Array<Array<number>>} */\n      (objectStack[objectStack.length - 1]);\n    flatLinearRings[0] = flatLinearRing;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction linkParser(node, objectStack) {\n  parseNode(LINK_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction whenParser(node, objectStack) {\n  const gxTrackObject =\n    /** @type {GxTrackObject} */\n    (objectStack[objectStack.length - 1]);\n  const whens = gxTrackObject.whens;\n  const s = getAllTextContent(node, false);\n  const when = Date.parse(s);\n  whens.push(isNaN(when) ? 0 : when);\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the color to.\n * @param {import(\"../color.js\").Color|string} color Color.\n */\nfunction writeColorTextNode(node, color) {\n  const rgba = asArray(color);\n  const opacity = rgba.length == 4 ? rgba[3] : 1;\n  /** @type {Array<string|number>} */\n  const abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];\n  for (let i = 0; i < 4; ++i) {\n    const hex = Math.floor(/** @type {number} */ (abgr[i])).toString(16);\n    abgr[i] = hex.length == 1 ? '0' + hex : hex;\n  }\n  writeStringTextNode(node, abgr.join(''));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the coordinates to.\n * @param {Array<number>} coordinates Coordinates.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeCoordinatesTextNode(node, coordinates, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n\n  const layout = context['layout'];\n  const stride = context['stride'];\n\n  let dimension;\n  if (layout == 'XY' || layout == 'XYM') {\n    dimension = 2;\n  } else if (layout == 'XYZ' || layout == 'XYZM') {\n    dimension = 3;\n  } else {\n    assert(false, 34); // Invalid geometry layout\n  }\n\n  const ii = coordinates.length;\n  let text = '';\n  if (ii > 0) {\n    text += coordinates[0];\n    for (let d = 1; d < dimension; ++d) {\n      text += ',' + coordinates[d];\n    }\n    for (let i = stride; i < ii; i += stride) {\n      text += ' ' + coordinates[i];\n      for (let d = 1; d < dimension; ++d) {\n        text += ',' + coordinates[i + d];\n      }\n    }\n  }\n  writeStringTextNode(node, text);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Data': makeChildAppender(writeDataNode),\n  'value': makeChildAppender(writeDataNodeValue),\n  'displayName': makeChildAppender(writeDataNodeName),\n});\n\n/**\n * @param {Element} node Node.\n * @param {{name: *, value: *}} pair Name value pair.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeDataNode(node, pair, objectStack) {\n  node.setAttribute('name', pair.name);\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const value = pair.value;\n\n  if (typeof value == 'object') {\n    if (value !== null && value.displayName) {\n      pushSerializeAndPop(\n        context,\n        EXTENDEDDATA_NODE_SERIALIZERS,\n        OBJECT_PROPERTY_NODE_FACTORY,\n        [value.displayName],\n        objectStack,\n        ['displayName']\n      );\n    }\n\n    if (value !== null && value.value) {\n      pushSerializeAndPop(\n        context,\n        EXTENDEDDATA_NODE_SERIALIZERS,\n        OBJECT_PROPERTY_NODE_FACTORY,\n        [value.value],\n        objectStack,\n        ['value']\n      );\n    }\n  } else {\n    pushSerializeAndPop(\n      context,\n      EXTENDEDDATA_NODE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      [value],\n      objectStack,\n      ['value']\n    );\n  }\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the name to.\n * @param {string} name DisplayName.\n */\nfunction writeDataNodeName(node, name) {\n  writeCDATASection(node, name);\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the value to.\n * @param {string} value Value.\n */\nfunction writeDataNodeValue(node, value) {\n  writeStringTextNode(node, value);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst DOCUMENT_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Placemark': makeChildAppender(writePlacemark),\n});\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst DOCUMENT_NODE_FACTORY = function (value, objectStack, nodeName) {\n  const parentNode = objectStack[objectStack.length - 1].node;\n  return createElementNS(parentNode.namespaceURI, 'Placemark');\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<Feature>} features Features.\n * @param {Array<*>} objectStack Object stack.\n * @this {KML}\n */\nfunction writeDocument(node, features, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  pushSerializeAndPop(\n    context,\n    DOCUMENT_SERIALIZERS,\n    DOCUMENT_NODE_FACTORY,\n    features,\n    objectStack,\n    undefined,\n    this\n  );\n}\n\n/**\n * A factory for creating Data nodes.\n * @const\n * @type {function(*, Array<*>): (Node|undefined)}\n */\nconst DATA_NODE_FACTORY = makeSimpleNodeFactory('Data');\n\n/**\n * @param {Element} node Node.\n * @param {{names: Array<string>, values: (Array<*>)}} namesAndValues Names and values.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeExtendedData(node, namesAndValues, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const names = namesAndValues.names;\n  const values = namesAndValues.values;\n  const length = names.length;\n\n  for (let i = 0; i < length; i++) {\n    pushSerializeAndPop(\n      context,\n      EXTENDEDDATA_NODE_SERIALIZERS,\n      DATA_NODE_FACTORY,\n      [{name: names[i], value: values[i]}],\n      objectStack\n    );\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst ICON_SEQUENCE = makeStructureNS(\n  NAMESPACE_URIS,\n  ['href'],\n  makeStructureNS(GX_NAMESPACE_URIS, ['x', 'y', 'w', 'h'])\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst ICON_SERIALIZERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'href': makeChildAppender(writeStringTextNode),\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'x': makeChildAppender(writeDecimalTextNode),\n    'y': makeChildAppender(writeDecimalTextNode),\n    'w': makeChildAppender(writeDecimalTextNode),\n    'h': makeChildAppender(writeDecimalTextNode),\n  })\n);\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst GX_NODE_FACTORY = function (value, objectStack, nodeName) {\n  return createElementNS(GX_NAMESPACE_URIS[0], 'gx:' + nodeName);\n};\n\n/**\n * @param {Element} node Node.\n * @param {Object} icon Icon object.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeIcon(node, icon, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const parentNode = objectStack[objectStack.length - 1].node;\n  let orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];\n  let values = makeSequence(icon, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    ICON_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n  orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];\n  values = makeSequence(icon, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    ICON_SERIALIZERS,\n    GX_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst ICON_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'scale',\n  'heading',\n  'Icon',\n  'color',\n  'hotSpot',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst ICON_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Icon': makeChildAppender(writeIcon),\n  'color': makeChildAppender(writeColorTextNode),\n  'heading': makeChildAppender(writeDecimalTextNode),\n  'hotSpot': makeChildAppender(writeVec2),\n  'scale': makeChildAppender(writeScaleTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../style/Icon.js\").default} style Icon style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeIconStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const /** @type {Object<string, any>} */ properties = {};\n  const src = style.getSrc();\n  const size = style.getSize();\n  const iconImageSize = style.getImageSize();\n  const iconProperties = {\n    'href': src,\n  };\n\n  if (size) {\n    iconProperties['w'] = size[0];\n    iconProperties['h'] = size[1];\n    const anchor = style.getAnchor(); // top-left\n    const origin = style.getOrigin(); // top-left\n\n    if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {\n      iconProperties['x'] = origin[0];\n      iconProperties['y'] = iconImageSize[1] - (origin[1] + size[1]);\n    }\n\n    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {\n      const /** @type {Vec2} */ hotSpot = {\n          x: anchor[0],\n          xunits: 'pixels',\n          y: size[1] - anchor[1],\n          yunits: 'pixels',\n        };\n      properties['hotSpot'] = hotSpot;\n    }\n  }\n\n  properties['Icon'] = iconProperties;\n\n  let scale = style.getScaleArray()[0];\n  let imageSize = size;\n  if (imageSize === null) {\n    imageSize = DEFAULT_IMAGE_STYLE_SIZE;\n  }\n  if (imageSize.length == 2) {\n    const resizeScale = scaleForSize(imageSize);\n    scale = scale / resizeScale;\n  }\n  if (scale !== 1) {\n    properties['scale'] = scale;\n  }\n\n  const rotation = style.getRotation();\n  if (rotation !== 0) {\n    properties['heading'] = rotation; // 0-360\n  }\n\n  const color = style.getColor();\n  if (color) {\n    properties['color'] = color;\n  }\n\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    ICON_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'color',\n  'scale',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'scale': makeChildAppender(writeScaleTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Text} style style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeLabelStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const properties = {};\n  const fill = style.getFill();\n  if (fill) {\n    properties['color'] = fill.getColor();\n  }\n  const scale = style.getScale();\n  if (scale && scale !== 1) {\n    properties['scale'] = scale;\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    LABEL_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst LINE_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['color', 'width']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst LINE_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'width': makeChildAppender(writeDecimalTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Stroke} style style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeLineStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const properties = {\n    'color': style.getColor(),\n    'width': Number(style.getWidth()) || 1,\n  };\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    LINE_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst GEOMETRY_TYPE_TO_NODENAME = {\n  'Point': 'Point',\n  'LineString': 'LineString',\n  'LinearRing': 'LinearRing',\n  'Polygon': 'Polygon',\n  'MultiPoint': 'MultiGeometry',\n  'MultiLineString': 'MultiGeometry',\n  'MultiPolygon': 'MultiGeometry',\n  'GeometryCollection': 'MultiGeometry',\n};\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst GEOMETRY_NODE_FACTORY = function (value, objectStack, nodeName) {\n  if (value) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      parentNode.namespaceURI,\n      GEOMETRY_TYPE_TO_NODENAME[\n        /** @type {import(\"../geom/Geometry.js\").default} */ (value).getType()\n      ]\n    );\n  }\n};\n\n/**\n * A factory for creating Point nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst POINT_NODE_FACTORY = makeSimpleNodeFactory('Point');\n\n/**\n * A factory for creating LineString nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory('LineString');\n\n/**\n * A factory for creating LinearRing nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory('LinearRing');\n\n/**\n * A factory for creating Polygon nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst POLYGON_NODE_FACTORY = makeSimpleNodeFactory('Polygon');\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'LineString': makeChildAppender(writePrimitiveGeometry),\n  'Point': makeChildAppender(writePrimitiveGeometry),\n  'Polygon': makeChildAppender(writePolygon),\n  'GeometryCollection': makeChildAppender(writeMultiGeometry),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeMultiGeometry(node, geometry, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const context = {node: node};\n  const type = geometry.getType();\n  /** @type {Array<import(\"../geom/Geometry.js\").default>} */\n  let geometries = [];\n  /** @type {function(*, Array<*>, string=): (Node|undefined)} */\n  let factory;\n  if (type === 'GeometryCollection') {\n    /** @type {GeometryCollection} */ (geometry)\n      .getGeometriesArrayRecursive()\n      .forEach(function (geometry) {\n        const type = geometry.getType();\n        if (type === 'MultiPoint') {\n          geometries = geometries.concat(\n            /** @type {MultiPoint} */ (geometry).getPoints()\n          );\n        } else if (type === 'MultiLineString') {\n          geometries = geometries.concat(\n            /** @type {MultiLineString} */ (geometry).getLineStrings()\n          );\n        } else if (type === 'MultiPolygon') {\n          geometries = geometries.concat(\n            /** @type {MultiPolygon} */ (geometry).getPolygons()\n          );\n        } else if (\n          type === 'Point' ||\n          type === 'LineString' ||\n          type === 'Polygon'\n        ) {\n          geometries.push(geometry);\n        } else {\n          assert(false, 39); // Unknown geometry type\n        }\n      });\n    factory = GEOMETRY_NODE_FACTORY;\n  } else if (type === 'MultiPoint') {\n    geometries = /** @type {MultiPoint} */ (geometry).getPoints();\n    factory = POINT_NODE_FACTORY;\n  } else if (type === 'MultiLineString') {\n    geometries = /** @type {MultiLineString} */ (geometry).getLineStrings();\n    factory = LINE_STRING_NODE_FACTORY;\n  } else if (type === 'MultiPolygon') {\n    geometries = /** @type {MultiPolygon} */ (geometry).getPolygons();\n    factory = POLYGON_NODE_FACTORY;\n  } else {\n    assert(false, 39); // Unknown geometry type\n  }\n  pushSerializeAndPop(\n    context,\n    MULTI_GEOMETRY_SERIALIZERS,\n    factory,\n    geometries,\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst BOUNDARY_IS_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'LinearRing': makeChildAppender(writePrimitiveGeometry),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/LinearRing.js\").default} linearRing Linear ring.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeBoundaryIs(node, linearRing, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  pushSerializeAndPop(\n    context,\n    BOUNDARY_IS_SERIALIZERS,\n    LINEAR_RING_NODE_FACTORY,\n    [linearRing],\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst PLACEMARK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'ExtendedData': makeChildAppender(writeExtendedData),\n  'MultiGeometry': makeChildAppender(writeMultiGeometry),\n  'LineString': makeChildAppender(writePrimitiveGeometry),\n  'LinearRing': makeChildAppender(writePrimitiveGeometry),\n  'Point': makeChildAppender(writePrimitiveGeometry),\n  'Polygon': makeChildAppender(writePolygon),\n  'Style': makeChildAppender(writeStyle),\n  'address': makeChildAppender(writeStringTextNode),\n  'description': makeChildAppender(writeStringTextNode),\n  'name': makeChildAppender(writeStringTextNode),\n  'open': makeChildAppender(writeBooleanTextNode),\n  'phoneNumber': makeChildAppender(writeStringTextNode),\n  'styleUrl': makeChildAppender(writeStringTextNode),\n  'visibility': makeChildAppender(writeBooleanTextNode),\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst PLACEMARK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'name',\n  'open',\n  'visibility',\n  'address',\n  'phoneNumber',\n  'description',\n  'styleUrl',\n  'Style',\n]);\n\n/**\n * A factory for creating ExtendedData nodes.\n * @const\n * @type {function(*, Array<*>): (Node|undefined)}\n */\nconst EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory('ExtendedData');\n\n/**\n * FIXME currently we do serialize arbitrary/custom feature properties\n * (ExtendedData).\n * @param {Element} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n * @this {KML}\n */\nfunction writePlacemark(node, feature, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n\n  // set id\n  if (feature.getId()) {\n    node.setAttribute('id', /** @type {string} */ (feature.getId()));\n  }\n\n  // serialize properties (properties unknown to KML are not serialized)\n  const properties = feature.getProperties();\n\n  // don't export these to ExtendedData\n  const filter = {\n    'address': 1,\n    'description': 1,\n    'name': 1,\n    'open': 1,\n    'phoneNumber': 1,\n    'styleUrl': 1,\n    'visibility': 1,\n  };\n  filter[feature.getGeometryName()] = 1;\n  const keys = Object.keys(properties || {})\n    .sort()\n    .filter(function (v) {\n      return !filter[v];\n    });\n\n  const styleFunction = feature.getStyleFunction();\n  if (styleFunction) {\n    // FIXME the styles returned by the style function are supposed to be\n    // resolution-independent here\n    const styles = styleFunction(feature, 0);\n    if (styles) {\n      const styleArray = Array.isArray(styles) ? styles : [styles];\n      let pointStyles = styleArray;\n      if (feature.getGeometry()) {\n        pointStyles = styleArray.filter(function (style) {\n          const geometry = style.getGeometryFunction()(feature);\n          if (geometry) {\n            const type = geometry.getType();\n            if (type === 'GeometryCollection') {\n              return /** @type {GeometryCollection} */ (geometry)\n                .getGeometriesArrayRecursive()\n                .filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type === 'Point' || type === 'MultiPoint';\n                }).length;\n            }\n            return type === 'Point' || type === 'MultiPoint';\n          }\n        });\n        ('Point');\n      }\n      if (this.writeStyles_) {\n        let lineStyles = styleArray;\n        let polyStyles = styleArray;\n        if (feature.getGeometry()) {\n          lineStyles = styleArray.filter(function (style) {\n            const geometry = style.getGeometryFunction()(feature);\n            if (geometry) {\n              const type = geometry.getType();\n              if (type === 'GeometryCollection') {\n                return /** @type {GeometryCollection} */ (geometry)\n                  .getGeometriesArrayRecursive()\n                  .filter(function (geometry) {\n                    const type = geometry.getType();\n                    return type === 'LineString' || type === 'MultiLineString';\n                  }).length;\n              }\n              return type === 'LineString' || type === 'MultiLineString';\n            }\n          });\n          polyStyles = styleArray.filter(function (style) {\n            const geometry = style.getGeometryFunction()(feature);\n            if (geometry) {\n              const type = geometry.getType();\n              if (type === 'GeometryCollection') {\n                return /** @type {GeometryCollection} */ (geometry)\n                  .getGeometriesArrayRecursive()\n                  .filter(function (geometry) {\n                    const type = geometry.getType();\n                    return type === 'Polygon' || type === 'MultiPolygon';\n                  }).length;\n              }\n              return type === 'Polygon' || type === 'MultiPolygon';\n            }\n          });\n        }\n        properties['Style'] = {\n          pointStyles: pointStyles,\n          lineStyles: lineStyles,\n          polyStyles: polyStyles,\n        };\n      }\n      if (pointStyles.length && properties['name'] === undefined) {\n        const textStyle = pointStyles[0].getText();\n        if (textStyle) {\n          properties['name'] = textStyle.getText();\n        }\n      }\n    }\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    PLACEMARK_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n\n  if (keys.length > 0) {\n    const sequence = makeSequence(properties, keys);\n    const namesAndValues = {names: keys, values: sequence};\n    pushSerializeAndPop(\n      context,\n      PLACEMARK_SERIALIZERS,\n      EXTENDEDDATA_NODE_FACTORY,\n      [namesAndValues],\n      objectStack\n    );\n  }\n\n  // serialize geometry\n  const options = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n    objectStack[0]\n  );\n  let geometry = feature.getGeometry();\n  if (geometry) {\n    geometry = transformGeometryWithOptions(geometry, true, options);\n  }\n  pushSerializeAndPop(\n    context,\n    PLACEMARK_SERIALIZERS,\n    GEOMETRY_NODE_FACTORY,\n    [geometry],\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'extrude',\n  'tessellate',\n  'altitudeMode',\n  'coordinates',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'extrude': makeChildAppender(writeBooleanTextNode),\n  'tessellate': makeChildAppender(writeBooleanTextNode),\n  'altitudeMode': makeChildAppender(writeStringTextNode),\n  'coordinates': makeChildAppender(writeCoordinatesTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePrimitiveGeometry(node, geometry, objectStack) {\n  const flatCoordinates = geometry.getFlatCoordinates();\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  context['layout'] = geometry.getLayout();\n  context['stride'] = geometry.getStride();\n\n  // serialize properties (properties unknown to KML are not serialized)\n  const properties = geometry.getProperties();\n  properties.coordinates = flatCoordinates;\n\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    PRIMITIVE_GEOMETRY_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst POLY_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'color',\n  'fill',\n  'outline',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst POLYGON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'outerBoundaryIs': makeChildAppender(writeBoundaryIs),\n  'innerBoundaryIs': makeChildAppender(writeBoundaryIs),\n});\n\n/**\n * A factory for creating innerBoundaryIs nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('innerBoundaryIs');\n\n/**\n * A factory for creating outerBoundaryIs nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('outerBoundaryIs');\n\n/**\n * @param {Element} node Node.\n * @param {Polygon} polygon Polygon.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePolygon(node, polygon, objectStack) {\n  const linearRings = polygon.getLinearRings();\n  const outerRing = linearRings.shift();\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  // inner rings\n  pushSerializeAndPop(\n    context,\n    POLYGON_SERIALIZERS,\n    INNER_BOUNDARY_NODE_FACTORY,\n    linearRings,\n    objectStack\n  );\n  // outer ring\n  pushSerializeAndPop(\n    context,\n    POLYGON_SERIALIZERS,\n    OUTER_BOUNDARY_NODE_FACTORY,\n    [outerRing],\n    objectStack\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst POLY_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'fill': makeChildAppender(writeBooleanTextNode),\n  'outline': makeChildAppender(writeBooleanTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Style} style Style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePolyStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const fill = style.getFill();\n  const stroke = style.getStroke();\n  const properties = {\n    'color': fill ? fill.getColor() : undefined,\n    'fill': fill ? undefined : false,\n    'outline': stroke ? undefined : false,\n  };\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    POLY_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the scale to.\n * @param {number|undefined} scale Scale.\n */\nfunction writeScaleTextNode(node, scale) {\n  // the Math is to remove any excess decimals created by float arithmetic\n  writeDecimalTextNode(node, Math.round(scale * 1e6) / 1e6);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'IconStyle',\n  'LabelStyle',\n  'LineStyle',\n  'PolyStyle',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'IconStyle': makeChildAppender(writeIconStyle),\n  'LabelStyle': makeChildAppender(writeLabelStyle),\n  'LineStyle': makeChildAppender(writeLineStyle),\n  'PolyStyle': makeChildAppender(writePolyStyle),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Object<string, Array<Style>>} styles Styles.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeStyle(node, styles, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const properties = {};\n  if (styles.pointStyles.length) {\n    const textStyle = styles.pointStyles[0].getText();\n    if (textStyle) {\n      properties['LabelStyle'] = textStyle;\n    }\n    const imageStyle = styles.pointStyles[0].getImage();\n    if (\n      imageStyle &&\n      typeof (/** @type {?} */ (imageStyle).getSrc) === 'function'\n    ) {\n      properties['IconStyle'] = imageStyle;\n    }\n  }\n  if (styles.lineStyles.length) {\n    const strokeStyle = styles.lineStyles[0].getStroke();\n    if (strokeStyle) {\n      properties['LineStyle'] = strokeStyle;\n    }\n  }\n  if (styles.polyStyles.length) {\n    const strokeStyle = styles.polyStyles[0].getStroke();\n    if (strokeStyle && !properties['LineStyle']) {\n      properties['LineStyle'] = strokeStyle;\n    }\n    properties['PolyStyle'] = styles.polyStyles[0];\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys\n  );\n}\n\n/**\n * @param {Element} node Node to append a TextNode with the Vec2 to.\n * @param {Vec2} vec2 Vec2.\n */\nfunction writeVec2(node, vec2) {\n  node.setAttribute('x', String(vec2.x));\n  node.setAttribute('y', String(vec2.y));\n  node.setAttribute('xunits', vec2.xunits);\n  node.setAttribute('yunits', vec2.yunits);\n}\n\nexport default KML;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}