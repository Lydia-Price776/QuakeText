{"ast":null,"code":"/**\n * @module ol/format/IGC\n */\nimport Feature from '../Feature.js';\nimport LineString from '../geom/LineString.js';\nimport TextFeature from './TextFeature.js';\nimport { get as getProjection } from '../proj.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n\n/**\n * @typedef {'barometric' | 'gps' | 'none'} IGCZ\n * IGC altitude/z. One of 'barometric', 'gps', 'none'.\n */\n\n/**\n * @const\n * @type {RegExp}\n */\nconst B_RECORD_RE = /^B(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{5})([NS])(\\d{3})(\\d{5})([EW])([AV])(\\d{5})(\\d{5})/;\n\n/**\n * @const\n * @type {RegExp}\n */\nconst H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;\n\n/**\n * @const\n * @type {RegExp}\n */\nconst HFDTE_RECORD_RE = /^HFDTE(\\d{2})(\\d{2})(\\d{2})/;\n\n/**\n * A regular expression matching the newline characters `\\r\\n`, `\\r` and `\\n`.\n *\n * @const\n * @type {RegExp}\n */\nconst NEWLINE_RE = /\\r\\n|\\r|\\n/;\n\n/**\n * @typedef {Object} Options\n * @property {IGCZ} [altitudeMode='none'] Altitude mode. Possible\n * values are `'barometric'`, `'gps'`, and `'none'`.\n */\n\n/**\n * @classdesc\n * Feature format for `*.igc` flight recording files.\n *\n * As IGC sources contain a single feature,\n * {@link module:ol/format/IGC~IGC#readFeatures} will return the feature in an\n * array\n *\n * @api\n */\nclass IGC extends TextFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {IGCZ}\n     */\n    this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : 'none';\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, options) {\n    const altitudeMode = this.altitudeMode_;\n    const lines = text.split(NEWLINE_RE);\n    /** @type {Object<string, string>} */\n    const properties = {};\n    const flatCoordinates = [];\n    let year = 2000;\n    let month = 0;\n    let day = 1;\n    let lastDateTime = -1;\n    let i, ii;\n    for (i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      let m;\n      if (line.charAt(0) == 'B') {\n        m = B_RECORD_RE.exec(line);\n        if (m) {\n          const hour = parseInt(m[1], 10);\n          const minute = parseInt(m[2], 10);\n          const second = parseInt(m[3], 10);\n          let y = parseInt(m[4], 10) + parseInt(m[5], 10) / 60000;\n          if (m[6] == 'S') {\n            y = -y;\n          }\n          let x = parseInt(m[7], 10) + parseInt(m[8], 10) / 60000;\n          if (m[9] == 'W') {\n            x = -x;\n          }\n          flatCoordinates.push(x, y);\n          if (altitudeMode != 'none') {\n            let z;\n            if (altitudeMode == 'gps') {\n              z = parseInt(m[11], 10);\n            } else if (altitudeMode == 'barometric') {\n              z = parseInt(m[12], 10);\n            } else {\n              z = 0;\n            }\n            flatCoordinates.push(z);\n          }\n          let dateTime = Date.UTC(year, month, day, hour, minute, second);\n          // Detect UTC midnight wrap around.\n          if (dateTime < lastDateTime) {\n            dateTime = Date.UTC(year, month, day + 1, hour, minute, second);\n          }\n          flatCoordinates.push(dateTime / 1000);\n          lastDateTime = dateTime;\n        }\n      } else if (line.charAt(0) == 'H') {\n        m = HFDTE_RECORD_RE.exec(line);\n        if (m) {\n          day = parseInt(m[1], 10);\n          month = parseInt(m[2], 10) - 1;\n          year = 2000 + parseInt(m[3], 10);\n        } else {\n          m = H_RECORD_RE.exec(line);\n          if (m) {\n            properties[m[1]] = m[2].trim();\n          }\n        }\n      }\n    }\n    if (flatCoordinates.length === 0) {\n      return null;\n    }\n    const layout = altitudeMode == 'none' ? 'XYM' : 'XYZM';\n    const lineString = new LineString(flatCoordinates, layout);\n    const feature = new Feature(transformGeometryWithOptions(lineString, false, options));\n    feature.setProperties(properties, true);\n    return feature;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromText(text, options) {\n    const feature = this.readFeatureFromText(text, options);\n    if (feature) {\n      return [feature];\n    } else {\n      return [];\n    }\n  }\n}\nexport default IGC;","map":{"version":3,"names":["Feature","LineString","TextFeature","get","getProjection","transformGeometryWithOptions","B_RECORD_RE","H_RECORD_RE","HFDTE_RECORD_RE","NEWLINE_RE","IGC","constructor","options","dataProjection","altitudeMode_","altitudeMode","readFeatureFromText","text","lines","split","properties","flatCoordinates","year","month","day","lastDateTime","i","ii","length","line","m","charAt","exec","hour","parseInt","minute","second","y","x","push","z","dateTime","Date","UTC","trim","layout","lineString","feature","setProperties","readFeaturesFromText"],"sources":["/Users/lydiaprice/quake-text/Frontend/node_modules/ol/format/IGC.js"],"sourcesContent":["/**\n * @module ol/format/IGC\n */\nimport Feature from '../Feature.js';\nimport LineString from '../geom/LineString.js';\nimport TextFeature from './TextFeature.js';\nimport {get as getProjection} from '../proj.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {'barometric' | 'gps' | 'none'} IGCZ\n * IGC altitude/z. One of 'barometric', 'gps', 'none'.\n */\n\n/**\n * @const\n * @type {RegExp}\n */\nconst B_RECORD_RE =\n  /^B(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{5})([NS])(\\d{3})(\\d{5})([EW])([AV])(\\d{5})(\\d{5})/;\n\n/**\n * @const\n * @type {RegExp}\n */\nconst H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;\n\n/**\n * @const\n * @type {RegExp}\n */\nconst HFDTE_RECORD_RE = /^HFDTE(\\d{2})(\\d{2})(\\d{2})/;\n\n/**\n * A regular expression matching the newline characters `\\r\\n`, `\\r` and `\\n`.\n *\n * @const\n * @type {RegExp}\n */\nconst NEWLINE_RE = /\\r\\n|\\r|\\n/;\n\n/**\n * @typedef {Object} Options\n * @property {IGCZ} [altitudeMode='none'] Altitude mode. Possible\n * values are `'barometric'`, `'gps'`, and `'none'`.\n */\n\n/**\n * @classdesc\n * Feature format for `*.igc` flight recording files.\n *\n * As IGC sources contain a single feature,\n * {@link module:ol/format/IGC~IGC#readFeatures} will return the feature in an\n * array\n *\n * @api\n */\nclass IGC extends TextFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {IGCZ}\n     */\n    this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : 'none';\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, options) {\n    const altitudeMode = this.altitudeMode_;\n    const lines = text.split(NEWLINE_RE);\n    /** @type {Object<string, string>} */\n    const properties = {};\n    const flatCoordinates = [];\n    let year = 2000;\n    let month = 0;\n    let day = 1;\n    let lastDateTime = -1;\n    let i, ii;\n    for (i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      let m;\n      if (line.charAt(0) == 'B') {\n        m = B_RECORD_RE.exec(line);\n        if (m) {\n          const hour = parseInt(m[1], 10);\n          const minute = parseInt(m[2], 10);\n          const second = parseInt(m[3], 10);\n          let y = parseInt(m[4], 10) + parseInt(m[5], 10) / 60000;\n          if (m[6] == 'S') {\n            y = -y;\n          }\n          let x = parseInt(m[7], 10) + parseInt(m[8], 10) / 60000;\n          if (m[9] == 'W') {\n            x = -x;\n          }\n          flatCoordinates.push(x, y);\n          if (altitudeMode != 'none') {\n            let z;\n            if (altitudeMode == 'gps') {\n              z = parseInt(m[11], 10);\n            } else if (altitudeMode == 'barometric') {\n              z = parseInt(m[12], 10);\n            } else {\n              z = 0;\n            }\n            flatCoordinates.push(z);\n          }\n          let dateTime = Date.UTC(year, month, day, hour, minute, second);\n          // Detect UTC midnight wrap around.\n          if (dateTime < lastDateTime) {\n            dateTime = Date.UTC(year, month, day + 1, hour, minute, second);\n          }\n          flatCoordinates.push(dateTime / 1000);\n          lastDateTime = dateTime;\n        }\n      } else if (line.charAt(0) == 'H') {\n        m = HFDTE_RECORD_RE.exec(line);\n        if (m) {\n          day = parseInt(m[1], 10);\n          month = parseInt(m[2], 10) - 1;\n          year = 2000 + parseInt(m[3], 10);\n        } else {\n          m = H_RECORD_RE.exec(line);\n          if (m) {\n            properties[m[1]] = m[2].trim();\n          }\n        }\n      }\n    }\n    if (flatCoordinates.length === 0) {\n      return null;\n    }\n    const layout = altitudeMode == 'none' ? 'XYM' : 'XYZM';\n    const lineString = new LineString(flatCoordinates, layout);\n    const feature = new Feature(\n      transformGeometryWithOptions(lineString, false, options)\n    );\n    feature.setProperties(properties, true);\n    return feature;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromText(text, options) {\n    const feature = this.readFeatureFromText(text, options);\n    if (feature) {\n      return [feature];\n    } else {\n      return [];\n    }\n  }\n}\n\nexport default IGC;\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,OAAO,MAAM,eAAe;AACnC,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,WAAW,MAAM,kBAAkB;AAC1C,SAAQC,GAAG,IAAIC,aAAa,QAAO,YAAY;AAC/C,SAAQC,4BAA4B,QAAO,cAAc;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAMC,WAAW,GACf,qFAAqF;;AAEvF;AACA;AACA;AACA;AACA,MAAMC,WAAW,GAAG,uBAAuB;;AAE3C;AACA;AACA;AACA;AACA,MAAMC,eAAe,GAAG,6BAA6B;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,GAAG,YAAY;;AAE/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,GAAG,SAASR,WAAW,CAAC;EAC5B;AACF;AACA;EACES,WAAW,CAACC,OAAO,EAAE;IACnB,KAAK,EAAE;IAEPA,OAAO,GAAGA,OAAO,GAAGA,OAAO,GAAG,CAAC,CAAC;;IAEhC;AACJ;AACA;IACI,IAAI,CAACC,cAAc,GAAGT,aAAa,CAAC,WAAW,CAAC;;IAEhD;AACJ;AACA;AACA;IACI,IAAI,CAACU,aAAa,GAAGF,OAAO,CAACG,YAAY,GAAGH,OAAO,CAACG,YAAY,GAAG,MAAM;EAC3E;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEC,mBAAmB,CAACC,IAAI,EAAEL,OAAO,EAAE;IACjC,MAAMG,YAAY,GAAG,IAAI,CAACD,aAAa;IACvC,MAAMI,KAAK,GAAGD,IAAI,CAACE,KAAK,CAACV,UAAU,CAAC;IACpC;IACA,MAAMW,UAAU,GAAG,CAAC,CAAC;IACrB,MAAMC,eAAe,GAAG,EAAE;IAC1B,IAAIC,IAAI,GAAG,IAAI;IACf,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIC,GAAG,GAAG,CAAC;IACX,IAAIC,YAAY,GAAG,CAAC,CAAC;IACrB,IAAIC,CAAC,EAAEC,EAAE;IACT,KAAKD,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGT,KAAK,CAACU,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;MAC1C,MAAMG,IAAI,GAAGX,KAAK,CAACQ,CAAC,CAAC;MACrB,IAAII,CAAC;MACL,IAAID,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;QACzBD,CAAC,GAAGxB,WAAW,CAAC0B,IAAI,CAACH,IAAI,CAAC;QAC1B,IAAIC,CAAC,EAAE;UACL,MAAMG,IAAI,GAAGC,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;UAC/B,MAAMK,MAAM,GAAGD,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;UACjC,MAAMM,MAAM,GAAGF,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;UACjC,IAAIO,CAAC,GAAGH,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAGI,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK;UACvD,IAAIA,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;YACfO,CAAC,GAAG,CAACA,CAAC;UACR;UACA,IAAIC,CAAC,GAAGJ,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAGI,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK;UACvD,IAAIA,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;YACfQ,CAAC,GAAG,CAACA,CAAC;UACR;UACAjB,eAAe,CAACkB,IAAI,CAACD,CAAC,EAAED,CAAC,CAAC;UAC1B,IAAItB,YAAY,IAAI,MAAM,EAAE;YAC1B,IAAIyB,CAAC;YACL,IAAIzB,YAAY,IAAI,KAAK,EAAE;cACzByB,CAAC,GAAGN,QAAQ,CAACJ,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YACzB,CAAC,MAAM,IAAIf,YAAY,IAAI,YAAY,EAAE;cACvCyB,CAAC,GAAGN,QAAQ,CAACJ,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YACzB,CAAC,MAAM;cACLU,CAAC,GAAG,CAAC;YACP;YACAnB,eAAe,CAACkB,IAAI,CAACC,CAAC,CAAC;UACzB;UACA,IAAIC,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAACrB,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAES,IAAI,EAAEE,MAAM,EAAEC,MAAM,CAAC;UAC/D;UACA,IAAIK,QAAQ,GAAGhB,YAAY,EAAE;YAC3BgB,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAACrB,IAAI,EAAEC,KAAK,EAAEC,GAAG,GAAG,CAAC,EAAES,IAAI,EAAEE,MAAM,EAAEC,MAAM,CAAC;UACjE;UACAf,eAAe,CAACkB,IAAI,CAACE,QAAQ,GAAG,IAAI,CAAC;UACrChB,YAAY,GAAGgB,QAAQ;QACzB;MACF,CAAC,MAAM,IAAIZ,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE;QAChCD,CAAC,GAAGtB,eAAe,CAACwB,IAAI,CAACH,IAAI,CAAC;QAC9B,IAAIC,CAAC,EAAE;UACLN,GAAG,GAAGU,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;UACxBP,KAAK,GAAGW,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;UAC9BR,IAAI,GAAG,IAAI,GAAGY,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QAClC,CAAC,MAAM;UACLA,CAAC,GAAGvB,WAAW,CAACyB,IAAI,CAACH,IAAI,CAAC;UAC1B,IAAIC,CAAC,EAAE;YACLV,UAAU,CAACU,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,CAACc,IAAI,EAAE;UAChC;QACF;MACF;IACF;IACA,IAAIvB,eAAe,CAACO,MAAM,KAAK,CAAC,EAAE;MAChC,OAAO,IAAI;IACb;IACA,MAAMiB,MAAM,GAAG9B,YAAY,IAAI,MAAM,GAAG,KAAK,GAAG,MAAM;IACtD,MAAM+B,UAAU,GAAG,IAAI7C,UAAU,CAACoB,eAAe,EAAEwB,MAAM,CAAC;IAC1D,MAAME,OAAO,GAAG,IAAI/C,OAAO,CACzBK,4BAA4B,CAACyC,UAAU,EAAE,KAAK,EAAElC,OAAO,CAAC,CACzD;IACDmC,OAAO,CAACC,aAAa,CAAC5B,UAAU,EAAE,IAAI,CAAC;IACvC,OAAO2B,OAAO;EAChB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEE,oBAAoB,CAAChC,IAAI,EAAEL,OAAO,EAAE;IAClC,MAAMmC,OAAO,GAAG,IAAI,CAAC/B,mBAAmB,CAACC,IAAI,EAAEL,OAAO,CAAC;IACvD,IAAImC,OAAO,EAAE;MACX,OAAO,CAACA,OAAO,CAAC;IAClB,CAAC,MAAM;MACL,OAAO,EAAE;IACX;EACF;AACF;AAEA,eAAerC,GAAG"},"metadata":{},"sourceType":"module","externalDependencies":[]}